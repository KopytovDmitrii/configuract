import { computed, isComputedRef } from '../core/computed';\nimport { createReactive, effect } from '../core/reactive';\n\ndescribe('Computed свойства', () => {\n  test('должен создавать computed свойство', () => {\n    const state = createReactive({ count: 0 });\n    const doubleCount = computed(() => state.count * 2);\n    \n    expect(isComputedRef(doubleCount)).toBe(true);\n    expect(doubleCount.value).toBe(0);\n  });\n\n  test('должен обновляться при изменении зависимостей', () => {\n    const state = createReactive({ count: 5 });\n    const doubleCount = computed(() => state.count * 2);\n    \n    expect(doubleCount.value).toBe(10);\n    \n    state.count = 10;\n    expect(doubleCount.value).toBe(20);\n  });\n\n  test('должен кешировать результат', () => {\n    let callCount = 0;\n    const state = createReactive({ count: 1 });\n    \n    const expensiveComputed = computed(() => {\n      callCount++;\n      return state.count * 2;\n    });\n    \n    // Первый доступ\n    expect(expensiveComputed.value).toBe(2);\n    expect(callCount).toBe(1);\n    \n    // Второй доступ - должен использовать кеш\n    expect(expensiveComputed.value).toBe(2);\n    expect(callCount).toBe(1);\n    \n    // После изменения зависимости\n    state.count = 3;\n    expect(expensiveComputed.value).toBe(6);\n    expect(callCount).toBe(2);\n  });\n\n  test('должен работать с вложенными computed', () => {\n    const state = createReactive({ \n      firstName: 'John',\n      lastName: 'Doe'\n    });\n    \n    const fullName = computed(() => `${state.firstName} ${state.lastName}`);\n    const greeting = computed(() => `Hello, ${fullName.value}!`);\n    \n    expect(greeting.value).toBe('Hello, John Doe!');\n    \n    state.firstName = 'Jane';\n    expect(greeting.value).toBe('Hello, Jane Doe!');\n  });\n\n  test('должен работать с setter', () => {\n    const state = createReactive({ count: 0 });\n    \n    const doubleCount = computed({\n      get: () => state.count * 2,\n      set: (value) => {\n        state.count = value / 2;\n      }\n    });\n    \n    expect(doubleCount.value).toBe(0);\n    \n    doubleCount.value = 10;\n    expect(state.count).toBe(5);\n    expect(doubleCount.value).toBe(10);\n  });\n\n  test('должен правильно отслеживать зависимости', () => {\n    const state = createReactive({\n      condition: true,\n      a: 1,\n      b: 2\n    });\n    \n    let aAccessCount = 0;\n    let bAccessCount = 0;\n    \n    const conditional = computed(() => {\n      if (state.condition) {\n        aAccessCount++;\n        return state.a;\n      } else {\n        bAccessCount++;\n        return state.b;\n      }\n    });\n    \n    // Первый доступ\n    expect(conditional.value).toBe(1);\n    expect(aAccessCount).toBe(1);\n    expect(bAccessCount).toBe(0);\n    \n    // Изменяем a - должно пересчитаться\n    state.a = 10;\n    expect(conditional.value).toBe(10);\n    expect(aAccessCount).toBe(2);\n    \n    // Изменяем b - не должно пересчитаться, так как b не используется\n    state.b = 20;\n    expect(conditional.value).toBe(10);\n    expect(aAccessCount).toBe(2);\n    \n    // Меняем условие\n    state.condition = false;\n    expect(conditional.value).toBe(20);\n    expect(bAccessCount).toBe(1);\n    \n    // Теперь изменяем a - не должно пересчитаться\n    state.a = 100;\n    expect(conditional.value).toBe(20);\n    expect(aAccessCount).toBe(2);\n  });\n\n  test('должен работать с эффектами', () => {\n    const state = createReactive({ count: 0 });\n    const doubleCount = computed(() => state.count * 2);\n    \n    let effectCount = 0;\n    let lastValue = 0;\n    \n    effect(() => {\n      effectCount++;\n      lastValue = doubleCount.value;\n    });\n    \n    expect(effectCount).toBe(1);\n    expect(lastValue).toBe(0);\n    \n    state.count = 5;\n    expect(effectCount).toBe(2);\n    expect(lastValue).toBe(10);\n  });\n\n  test('должен правильно обрабатывать ошибки', () => {\n    const state = createReactive({ count: 0 });\n    \n    const errorComputed = computed(() => {\n      if (state.count < 0) {\n        throw new Error('Count cannot be negative');\n      }\n      return state.count * 2;\n    });\n    \n    expect(errorComputed.value).toBe(0);\n    \n    state.count = -1;\n    expect(() => errorComputed.value).toThrow('Count cannot be negative');\n  });\n\n  test('должен останавливать отслеживание при вызове stop', () => {\n    const state = createReactive({ count: 0 });\n    let callCount = 0;\n    \n    const computedValue = computed(() => {\n      callCount++;\n      return state.count * 2;\n    });\n    \n    expect(computedValue.value).toBe(0);\n    expect(callCount).toBe(1);\n    \n    state.count = 1;\n    expect(computedValue.value).toBe(2);\n    expect(callCount).toBe(2);\n    \n    // Останавливаем отслеживание\n    computedValue.effect.active = false;\n    \n    state.count = 2;\n    // Значение должно остаться прежним\n    expect(computedValue.value).toBe(2);\n    expect(callCount).toBe(2);\n  });\n});"
</invoke>