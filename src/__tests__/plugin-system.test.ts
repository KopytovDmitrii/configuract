import { Framework } from '../index';\nimport { PluginManager, definePlugin } from '../core/plugin-system';\nimport { Plugin, PluginContext } from '../core/types';\n\ndescribe('Система плагинов', () => {\n  let pluginManager: PluginManager;\n  \n  beforeEach(() => {\n    pluginManager = new PluginManager(Framework);\n  });\n  \n  afterEach(() => {\n    pluginManager.cleanup();\n  });\n\n  test('должен регистрировать и устанавливать плагин', () => {\n    let installed = false;\n    \n    const TestPlugin = definePlugin({\n      name: 'TestPlugin',\n      version: '1.0.0',\n      install(framework: any, context: PluginContext) {\n        installed = true;\n        expect(framework).toBeDefined();\n        expect(context).toBeDefined();\n      }\n    });\n    \n    pluginManager.use(TestPlugin);\n    \n    expect(installed).toBe(true);\n    expect(pluginManager.hasPlugin('TestPlugin')).toBe(true);\n  });\n\n  test('должен предотвращать повторную установку плагина', () => {\n    const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();\n    \n    const TestPlugin = definePlugin({\n      name: 'DuplicatePlugin',\n      install() {}\n    });\n    \n    pluginManager.use(TestPlugin);\n    pluginManager.use(TestPlugin); // Повторная установка\n    \n    expect(consoleSpy).toHaveBeenCalledWith(\n      expect.stringContaining('уже установлен')\n    );\n    \n    consoleSpy.mockRestore();\n  });\n\n  test('должен проверять зависимости плагинов', () => {\n    const DependentPlugin = definePlugin({\n      name: 'DependentPlugin',\n      dependencies: ['BasePlugin'],\n      install() {}\n    });\n    \n    expect(() => {\n      pluginManager.use(DependentPlugin);\n    }).toThrow('требует зависимость \"BasePlugin\"');\n  });\n\n  test('должен устанавливать плагины с зависимостями в правильном порядке', () => {\n    const BasePlugin = definePlugin({\n      name: 'BasePlugin',\n      install() {}\n    });\n    \n    const DependentPlugin = definePlugin({\n      name: 'DependentPlugin',\n      dependencies: ['BasePlugin'],\n      install() {}\n    });\n    \n    pluginManager.use(BasePlugin);\n    \n    expect(() => {\n      pluginManager.use(DependentPlugin);\n    }).not.toThrow();\n    \n    expect(pluginManager.hasPlugin('BasePlugin')).toBe(true);\n    expect(pluginManager.hasPlugin('DependentPlugin')).toBe(true);\n  });\n\n  test('должен передавать опции в плагин', () => {\n    let receivedOptions: any = null;\n    \n    const OptionsPlugin = definePlugin({\n      name: 'OptionsPlugin',\n      install(framework: any, context: PluginContext) {\n        receivedOptions = context.options;\n      }\n    });\n    \n    const options = { apiUrl: 'https://api.example.com', timeout: 5000 };\n    pluginManager.use(OptionsPlugin, options);\n    \n    expect(receivedOptions).toEqual(options);\n  });\n\n  test('должен позволять плагинам добавлять глобальные свойства', () => {\n    const GlobalPropsPlugin = definePlugin({\n      name: 'GlobalPropsPlugin',\n      install(framework: any, context: PluginContext) {\n        context.globalProperties.set('$myGlobal', 'test value');\n        framework.myMethod = () => 'method result';\n      }\n    });\n    \n    pluginManager.use(GlobalPropsPlugin);\n    \n    expect(pluginManager.getGlobalProperty('$myGlobal')).toBe('test value');\n    expect((Framework as any).myMethod()).toBe('method result');\n  });\n\n  test('должен позволять плагинам регистрировать директивы', () => {\n    const DirectivePlugin = definePlugin({\n      name: 'DirectivePlugin',\n      install(framework: any, context: PluginContext) {\n        const testDirective = {\n          name: 'test',\n          bind(el: HTMLElement, binding: any) {\n            el.setAttribute('data-test', binding.value);\n          }\n        };\n        \n        context.directives.set('test', testDirective);\n      }\n    });\n    \n    pluginManager.use(DirectivePlugin);\n    \n    expect(pluginManager.getDirective('test')).toBeDefined();\n  });\n\n  test('должен обрабатывать ошибки при установке плагинов', () => {\n    const consoleSpy = jest.spyOn(console, 'error').mockImplementation();\n    \n    const ErrorPlugin = definePlugin({\n      name: 'ErrorPlugin',\n      install() {\n        throw new Error('Installation failed');\n      }\n    });\n    \n    expect(() => {\n      pluginManager.use(ErrorPlugin);\n    }).toThrow('Installation failed');\n    \n    expect(consoleSpy).toHaveBeenCalled();\n    \n    consoleSpy.mockRestore();\n  });\n\n  test('должен удалять плагины (если поддерживается)', () => {\n    let uninstallCalled = false;\n    \n    const UninstallablePlugin = definePlugin({\n      name: 'UninstallablePlugin',\n      install() {},\n      uninstall() {\n        uninstallCalled = true;\n      }\n    });\n    \n    pluginManager.use(UninstallablePlugin);\n    expect(pluginManager.hasPlugin('UninstallablePlugin')).toBe(true);\n    \n    const success = pluginManager.uninstall('UninstallablePlugin');\n    expect(success).toBe(true);\n    expect(uninstallCalled).toBe(true);\n    expect(pluginManager.hasPlugin('UninstallablePlugin')).toBe(false);\n  });\n\n  test('должен получать список установленных плагинов', () => {\n    const Plugin1 = definePlugin({ name: 'Plugin1', install() {} });\n    const Plugin2 = definePlugin({ name: 'Plugin2', install() {} });\n    \n    pluginManager.use(Plugin1);\n    pluginManager.use(Plugin2);\n    \n    const installed = pluginManager.getInstalledPlugins();\n    expect(installed).toContain('Plugin1');\n    expect(installed).toContain('Plugin2');\n    expect(installed).toHaveLength(2);\n  });\n\n  test('должен очищать все плагины при cleanup', () => {\n    const Plugin1 = definePlugin({ name: 'Plugin1', install() {} });\n    const Plugin2 = definePlugin({ name: 'Plugin2', install() {} });\n    \n    pluginManager.use(Plugin1);\n    pluginManager.use(Plugin2);\n    \n    expect(pluginManager.getInstalledPlugins()).toHaveLength(2);\n    \n    pluginManager.cleanup();\n    \n    expect(pluginManager.getInstalledPlugins()).toHaveLength(0);\n  });\n});\n\n// Тесты встроенных плагинов\ndescribe('Встроенные плагины', () => {\n  beforeEach(() => {\n    Framework.cleanup();\n  });\n  \n  afterEach(() => {\n    Framework.cleanup();\n  });\n\n  describe('StorePlugin', () => {\n    test('должен создавать глобальное хранилище', () => {\n      const { StorePlugin } = require('../core/plugin-system');\n      \n      Framework.use(StorePlugin, {\n        state: {\n          count: 0\n        },\n        mutations: {\n          increment(state: any) {\n            state.count++;\n          }\n        },\n        actions: {\n          incrementAsync({ commit }: any) {\n            setTimeout(() => commit('increment'), 0);\n          }\n        }\n      });\n      \n      expect((Framework as any).$store).toBeDefined();\n      expect((Framework as any).$store.state.count).toBe(0);\n      \n      (Framework as any).$store.commit('increment');\n      expect((Framework as any).$store.state.count).toBe(1);\n    });\n  });\n\n  describe('I18nPlugin', () => {\n    test('должен предоставлять функции интернационализации', () => {\n      const { I18nPlugin } = require('../core/plugin-system');\n      \n      Framework.use(I18nPlugin, {\n        locale: 'ru',\n        messages: {\n          ru: {\n            hello: 'Привет'\n          },\n          en: {\n            hello: 'Hello'\n          }\n        }\n      });\n      \n      expect((Framework as any).t('hello')).toBe('Привет');\n      \n      (Framework as any).setLocale('en');\n      expect((Framework as any).t('hello')).toBe('Hello');\n    });\n  });\n\n  describe('FormValidationPlugin', () => {\n    test('должен регистрировать директиву валидации', () => {\n      const { FormValidationPlugin } = require('../core/plugin-system');\n      \n      Framework.use(FormValidationPlugin);\n      \n      expect((Framework as any).validators).toBeDefined();\n      expect((Framework as any).validators.required).toBeInstanceOf(Function);\n      expect((Framework as any).validators.email).toBeInstanceOf(Function);\n    });\n  });\n});"
</invoke>