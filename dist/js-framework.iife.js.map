{"version":3,"file":"js-framework.iife.js","sources":["../src/core/validator.ts","../src/core/reactive.ts","../src/core/component-registry.ts","../src/core/scheduler.ts","../src/core/directives.ts","../src/core/component-renderer.ts","../src/core/computed.ts","../src/core/plugin-system.ts","../src/core/performance.ts","../src/core/dom-differ.ts","../src/utils/helpers.ts","../src/index.ts","../src/core/renderer.ts"],"sourcesContent":["import { ElementConfig, ValidationResult, ValidationError, ElementProps, EventHandlers } from './types';\n\n/**\n * Класс для валидации конфигурации элементов\n */\nexport class ConfigValidator {\n  private validHtmlTags: Set<string>;\n  private usedIds: Set<string>;\n\n  constructor() {\n    // Основные HTML теги, поддерживаемые фреймворком\n    this.validHtmlTags = new Set([\n      'div', 'span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\n      'button', 'input', 'form', 'label', 'textarea', 'select', 'option',\n      'a', 'img', 'ul', 'ol', 'li', 'table', 'tr', 'td', 'th',\n      'header', 'footer', 'main', 'section', 'article', 'nav',\n      'strong', 'em', 'small', 'br', 'hr'\n    ]);\n    this.usedIds = new Set();\n  }\n\n  /**\n   * Сбросить состояние валидатора (список использованных ID)\n   */\n  reset(): void {\n    this.usedIds.clear();\n  }\n\n  /**\n   * Валидация конфигурации элемента\n   */\n  validate(config: ElementConfig, path = ''): ValidationResult {\n    const errors: ValidationError[] = [];\n\n    // Валидация основной структуры\n    if (!config || typeof config !== 'object') {\n      errors.push({\n        field: 'config',\n        message: 'Конфигурация должна быть объектом',\n        path,\n      });\n      return { isValid: false, errors };\n    }\n\n    // Валидация тега\n    this.validateTag(config, errors, path);\n\n    // Валидация свойств\n    if (config.props) {\n      this.validateProps(config.props, errors, path);\n    }\n\n    // Валидация дочерних элементов\n    if (config.children) {\n      this.validateChildren(config.children, errors, path);\n    }\n\n    // Валидация событий\n    if (config.events) {\n      this.validateEvents(config.events, errors, path);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Валидация HTML тега или компонента\n   */\n  private validateTag(config: ElementConfig, errors: ValidationError[], path: string): void {\n    // Для компонентов поле tag не требуется, проверяем наличие component\n    if (config.component) {\n      // Это компонент - валидируем имя компонента\n      if (typeof config.component !== 'string') {\n        errors.push({\n          field: 'component',\n          message: 'Имя компонента должно быть строкой',\n          path,\n        });\n      }\n      return; // Для компонентов не требуется tag\n    }\n    \n    // Для обычных элементов требуется tag\n    if (!config.tag) {\n      errors.push({\n        field: 'tag',\n        message: 'Поле tag является обязательным для элементов (или укажите component для компонентов)',\n        path,\n      });\n      return;\n    }\n\n    if (typeof config.tag !== 'string') {\n      errors.push({\n        field: 'tag',\n        message: 'Поле tag должно быть строкой',\n        path,\n      });\n      return;\n    }\n\n    if (!this.validHtmlTags.has(config.tag.toLowerCase())) {\n      errors.push({\n        field: 'tag',\n        message: `Неподдерживаемый HTML тег: ${config.tag}`,\n        path,\n      });\n    }\n  }\n\n  /**\n   * Валидация свойств элемента\n   */\n  private validateProps(props: ElementProps, errors: ValidationError[], path: string): void {\n    if (typeof props !== 'object' || props === null) {\n      errors.push({\n        field: 'props',\n        message: 'Свойства должны быть объектом',\n        path,\n      });\n      return;\n    }\n\n    // Валидация класса\n    if (props.class !== undefined) {\n      if (typeof props.class !== 'string') {\n        errors.push({\n          field: 'props.class',\n          message: 'Класс должен быть строкой',\n          path,\n        });\n      }\n    }\n\n    // Валидация ID\n    if (props.id !== undefined) {\n      if (typeof props.id !== 'string') {\n        errors.push({\n          field: 'props.id',\n          message: 'ID должен быть строкой',\n          path,\n        });\n      } else {\n        // Проверка на уникальность ID\n        if (this.usedIds.has(props.id)) {\n          errors.push({\n            field: 'props.id',\n            message: `Дублирующийся ID: ${props.id}`,\n            path,\n          });\n        } else {\n          this.usedIds.add(props.id);\n        }\n      }\n    }\n\n    // Валидация стилей\n    if (props.style !== undefined) {\n      if (typeof props.style !== 'object' || props.style === null) {\n        errors.push({\n          field: 'props.style',\n          message: 'Стили должны быть объектом',\n          path,\n        });\n      } else {\n        this.validateStyles(props.style, errors, path);\n      }\n    }\n  }\n\n  /**\n   * Валидация CSS стилей\n   */\n  private validateStyles(style: any, errors: ValidationError[], path: string): void {\n    for (const [property, value] of Object.entries(style)) {\n      if (typeof value !== 'string' && typeof value !== 'number') {\n        errors.push({\n          field: `props.style.${property}`,\n          message: `Значение стиля должно быть строкой или числом, получено: ${typeof value}`,\n          path,\n        });\n      }\n    }\n  }\n\n  /**\n   * Валидация дочерних элементов\n   */\n  private validateChildren(children: any, errors: ValidationError[], path: string): void {\n    if (!Array.isArray(children)) {\n      errors.push({\n        field: 'children',\n        message: 'Дочерние элементы должны быть массивом',\n        path,\n      });\n      return;\n    }\n\n    children.forEach((child, index) => {\n      const childPath = path ? `${path}.children[${index}]` : `children[${index}]`;\n\n      if (typeof child === 'string') {\n        // Текстовый узел - валидация не требуется\n        return;\n      }\n\n      if (typeof child === 'object' && child !== null) {\n        // Рекурсивная валидация дочернего элемента\n        const childResult = this.validate(child, childPath);\n        errors.push(...childResult.errors);\n      } else {\n        errors.push({\n          field: 'children',\n          message: `Дочерний элемент должен быть строкой или объектом конфигурации, получено: ${typeof child}`,\n          path: childPath,\n        });\n      }\n    });\n  }\n\n  /**\n   * Валидация обработчиков событий\n   */\n  private validateEvents(events: EventHandlers, errors: ValidationError[], path: string): void {\n    if (typeof events !== 'object' || events === null) {\n      errors.push({\n        field: 'events',\n        message: 'События должны быть объектом',\n        path,\n      });\n      return;\n    }\n\n    for (const [eventType, handler] of Object.entries(events)) {\n      if (typeof handler !== 'function') {\n        errors.push({\n          field: `events.${eventType}`,\n          message: `Обработчик события должен быть функцией, получено: ${typeof handler}`,\n          path,\n        });\n      }\n\n      // Проверка на валидные типы событий DOM\n      if (!this.isValidEventType(eventType)) {\n        errors.push({\n          field: `events.${eventType}`,\n          message: `Неподдерживаемый тип события: ${eventType}`,\n          path,\n        });\n      }\n    }\n  }\n\n  /**\n   * Проверка валидности типа события DOM\n   */\n  private isValidEventType(eventType: string): boolean {\n    const validDOMEvents = [\n      'click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout',\n      'mousemove', 'mouseenter', 'mouseleave',\n      'keydown', 'keyup', 'keypress',\n      'focus', 'blur', 'change', 'input', 'submit', 'reset',\n      'load', 'unload', 'resize', 'scroll',\n      'touchstart', 'touchend', 'touchmove', 'touchcancel'\n    ];\n    \n    // Кастомные события фреймворка\n    const customFrameworkEvents = [\n      'mounted', 'unmounted'\n    ];\n    \n    return validDOMEvents.includes(eventType) || customFrameworkEvents.includes(eventType);\n  }\n\n  /**\n   * Получить список поддерживаемых HTML тегов\n   */\n  getSupportedTags(): string[] {\n    return Array.from(this.validHtmlTags);\n  }\n\n  /**\n   * Добавить поддержку нового HTML тега\n   */\n  addSupportedTag(tag: string): void {\n    this.validHtmlTags.add(tag.toLowerCase());\n  }\n\n  /**\n   * Удалить поддержку HTML тега\n   */\n  removeSupportedTag(tag: string): void {\n    this.validHtmlTags.delete(tag.toLowerCase());\n  }\n}","import { \n  ReactiveEffect, \n  ReactiveProperty, \n  ReactiveOptions,\n  EffectOptions,\n  DebuggerEvent \n} from './types';\n\n/**\n * Активный эффект в данный момент\n */\nlet activeEffect: ReactiveEffect | undefined;\n\n/**\n * Стек активных эффектов\n */\nconst effectStack: ReactiveEffect[] = [];\n\n/**\n * WeakMap для отслеживания реактивных объектов\n */\nconst targetMap = new WeakMap<object, Map<string | symbol, ReactiveProperty>>();\n\n/**\n * WeakMap для хранения оригинальных объектов\n */\nconst reactiveMap = new WeakMap<object, object>();\nconst originalMap = new WeakMap<object, object>();\n\n/**\n * Создание реактивного Proxy объекта\n */\nexport function createReactive<T extends object>(\n  target: T, \n  options: ReactiveOptions = {}\n): T {\n  // Проверяем, не является ли объект уже реактивным\n  if (reactiveMap.has(target)) {\n    return reactiveMap.get(target) as T;\n  }\n\n  // Создаем Proxy\n  const proxy = new Proxy(target, {\n    get(obj: T, prop: string | symbol, receiver: any): any {\n      // Отслеживание доступа к свойству\n      track(target, prop);\n      \n      const value = Reflect.get(obj, prop, receiver);\n      \n      // Рекурсивная реактивность для вложенных объектов\n      if (options.deep !== false && typeof value === 'object' && value !== null) {\n        return createReactive(value, options);\n      }\n      \n      // Отладочная информация\n      if (options.debuggerOptions?.onTrack) {\n        options.debuggerOptions.onTrack({\n          type: 'get',\n          target: obj,\n          key: prop,\n          newValue: value\n        });\n      }\n      \n      return value;\n    },\n    \n    set(obj: T, prop: string | symbol, value: any, receiver: any): boolean {\n      const oldValue = (obj as any)[prop];\n      const hadKey = Object.prototype.hasOwnProperty.call(obj, prop);\n      const result = Reflect.set(obj, prop, value, receiver);\n      \n      // Уведомление об изменении только если значение действительно изменилось\n      if (!hadKey) {\n        // Новое свойство\n        trigger(target, prop, 'add', value, oldValue);\n      } else if (oldValue !== value) {\n        // Изменение существующего свойства\n        trigger(target, prop, 'set', value, oldValue);\n      }\n      \n      // Отладочная информация\n      if (options.debuggerOptions?.onTrigger) {\n        options.debuggerOptions.onTrigger({\n          type: hadKey ? 'set' : 'add',\n          target: obj,\n          key: prop,\n          newValue: value,\n          oldValue\n        });\n      }\n      \n      return result;\n    },\n    \n    deleteProperty(obj: T, prop: string | symbol): boolean {\n      const hadKey = Object.prototype.hasOwnProperty.call(obj, prop);\n      const oldValue = (obj as any)[prop];\n      const result = Reflect.deleteProperty(obj, prop);\n      \n      if (result && hadKey) {\n        trigger(target, prop, 'delete', undefined, oldValue);\n        \n        // Отладочная информация\n        if (options.debuggerOptions?.onTrigger) {\n          options.debuggerOptions.onTrigger({\n            type: 'delete',\n            target: obj,\n            key: prop,\n            oldValue\n          });\n        }\n      }\n      \n      return result;\n    }\n  });\n  \n  // Сохраняем связь между оригиналом и прокси\n  reactiveMap.set(target, proxy);\n  originalMap.set(proxy, target);\n  \n  return proxy;\n}\n\n/**\n * Отслеживание доступа к свойству\n */\nfunction track(target: object, key: string | symbol): void {\n  if (!activeEffect || !shouldTrack) {\n    return;\n  }\n  \n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    targetMap.set(target, (depsMap = new Map()));\n  }\n  \n  let dep = depsMap.get(key);\n  if (!dep) {\n    depsMap.set(key, (dep = { key: String(key), effects: new Set() }));\n  }\n  \n  // Добавляем текущий эффект к наблюдателям\n  dep.effects.add(activeEffect);\n  activeEffect.deps.add(dep);\n}\n\n/**\n * Уведомление об изменении свойства\n */\nfunction trigger(\n  target: object, \n  key: string | symbol, \n  type: 'set' | 'add' | 'delete' | 'clear',\n  newValue?: any,\n  oldValue?: any\n): void {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  \n  const effects = new Set<ReactiveEffect>();\n  \n  // Собираем все эффекты для данного ключа\n  const dep = depsMap.get(key);\n  if (dep) {\n    dep.effects.forEach(effect => {\n      if (effect !== activeEffect) {\n        effects.add(effect);\n      }\n    });\n  }\n  \n  // Для операций с массивами также триггерим length\n  if (type === 'add' || type === 'delete') {\n    if (Array.isArray(target)) {\n      const lengthDep = depsMap.get('length');\n      if (lengthDep) {\n        lengthDep.effects.forEach(effect => {\n          if (effect !== activeEffect) {\n            effects.add(effect);\n          }\n        });\n      }\n    }\n  }\n  \n  // Запускаем все собранные эффекты\n  effects.forEach(effect => {\n    if (effect.options?.scheduler) {\n      effect.options.scheduler(effect);\n    } else {\n      effect.fn();\n    }\n  });\n}\n\n/**\n * Флаг разрешения отслеживания\n */\nlet shouldTrack = true;\n\n/**\n * Приостановка отслеживания\n */\nexport function pauseTracking(): void {\n  shouldTrack = false;\n}\n\n/**\n * Возобновление отслеживания\n */\nexport function enableTracking(): void {\n  shouldTrack = true;\n}\n\n/**\n * Создание реактивного эффекта\n */\nexport function effect(\n  fn: Function, \n  options: EffectOptions = {}\n): ReactiveEffect {\n  const effectFn: ReactiveEffect = {\n    fn,\n    active: true,\n    deps: new Set(),\n    options\n  };\n  \n  if (!options.lazy) {\n    runEffect(effectFn);\n  }\n  \n  return effectFn;\n}\n\n/**\n * Запуск реактивного эффекта\n */\nfunction runEffect(effect: ReactiveEffect): any {\n  if (!effect.active) {\n    return effect.fn();\n  }\n  \n  // Очищаем старые зависимости\n  cleanupEffect(effect);\n  \n  try {\n    // Устанавливаем активный эффект\n    effectStack.push(effect);\n    activeEffect = effect;\n    \n    return effect.fn();\n  } finally {\n    // Восстанавливаем предыдущий активный эффект\n    effectStack.pop();\n    activeEffect = effectStack[effectStack.length - 1];\n  }\n}\n\n/**\n * Очистка зависимостей эффекта\n */\nfunction cleanupEffect(effect: ReactiveEffect): void {\n  effect.deps.forEach(dep => {\n    dep.effects.delete(effect);\n  });\n  effect.deps.clear();\n}\n\n/**\n * Остановка реактивного эффекта\n */\nexport function stop(effect: ReactiveEffect): void {\n  if (effect.active) {\n    cleanupEffect(effect);\n    effect.active = false;\n  }\n}\n\n/**\n * Проверка, является ли объект реактивным\n */\nexport function isReactive(value: any): boolean {\n  return originalMap.has(value);\n}\n\n/**\n * Получение оригинального объекта из реактивного\n */\nexport function toRaw<T>(observed: T): T {\n  const original = originalMap.get(observed as any);\n  return original ? original as T : observed;\n}\n\n/**\n * Создание shallow реактивного объекта (только первый уровень)\n */\nexport function shallowReactive<T extends object>(target: T): T {\n  return createReactive(target, { deep: false });\n}\n\n/**\n * Проверка, изменилось ли значение\n */\nexport function hasChanged(value: any, oldValue: any): boolean {\n  return !Object.is(value, oldValue);\n}\n\n// Экспортируем типы для совместимости\nexport type { ReactiveEffect, EffectOptions } from './types';","import { Component, ComponentInstance, PropDefinition } from './types';\nimport { createReactive } from './reactive';\n\n/**\n * Реестр компонентов фреймворка\n */\nclass ComponentRegistry {\n  private components = new Map<string, Component>();\n  private instances = new Map<string, ComponentInstance>();\n  private instanceCounter = 0;\n\n  /**\n   * Регистрация компонента\n   */\n  register(component: Component): void {\n    if (!component.name) {\n      throw new Error('Компонент должен иметь имя');\n    }\n\n    if (this.components.has(component.name)) {\n      console.warn(`Компонент \"${component.name}\" уже зарегистрирован. Перезаписываем.`);\n    }\n\n    // Валидация компонента\n    this.validateComponent(component);\n\n    this.components.set(component.name, component);\n  }\n\n  /**\n   * Получение компонента по имени\n   */\n  get(name: string): Component | undefined {\n    return this.components.get(name);\n  }\n\n  /**\n   * Проверка существования компонента\n   */\n  has(name: string): boolean {\n    return this.components.has(name);\n  }\n\n  /**\n   * Удаление компонента из реестра\n   */\n  unregister(name: string): boolean {\n    // Проверяем, нет ли активных экземпляров\n    const activeInstances = Array.from(this.instances.values())\n      .filter(instance => instance.component.name === name && instance.mounted);\n\n    if (activeInstances.length > 0) {\n      console.warn(\n        `Попытка удаления компонента \"${name}\" с ${activeInstances.length} активными экземплярами`\n      );\n      return false;\n    }\n\n    return this.components.delete(name);\n  }\n\n  /**\n   * Создание экземпляра компонента с полной поддержкой жизненного цикла\n   */\n  createInstance(componentName: string, props: any = {}): ComponentInstance {\n    const component = this.get(componentName);\n    if (!component) {\n      throw new Error(`Компонент \"${componentName}\" не найден`);\n    }\n\n    // Генерируем уникальный ID\n    const id = this.generateInstanceId();\n\n    // Валидируем и обрабатываем props\n    const validatedProps = this.validateAndNormalizeProps(props, component.props);\n\n    // Вызываем хук beforeCreate\n    try {\n      component.beforeCreate?.();\n    } catch (error) {\n      console.error(`Ошибка в хуке beforeCreate компонента \"${componentName}\":`, error);\n    }\n\n    // Создаем локальное состояние\n    const localState = component.state ? component.state() : {};\n    const reactiveState = createReactive(localState);\n\n    // Создаем computed свойства\n    const computedProperties: Record<string, any> = {};\n    if (component.computed) {\n      for (const [key, getter] of Object.entries(component.computed)) {\n        try {\n          // Создаем простую реализацию computed для прямого вызова\n          Object.defineProperty(computedProperties, key, {\n            get() {\n              return getter.call({ \n                state: reactiveState, \n                props: validatedProps,\n                computed: computedProperties\n              });\n            },\n            enumerable: true,\n            configurable: true\n          });\n        } catch (error) {\n          console.warn(`Ошибка при создании computed свойства \"${key}\":`, error);\n          computedProperties[key] = undefined;\n        }\n      }\n    }\n\n    // Создаем экземпляр\n    const instance: ComponentInstance = {\n      id,\n      component,\n      props: validatedProps,\n      state: reactiveState,\n      computed: computedProperties,\n      element: null,\n      mounted: false,\n      dependencies: new Set(),\n      children: [],\n      parent: null,\n      pluginContext: {},\n      cleanup: []\n    };\n\n    // Сохраняем экземпляр\n    this.instances.set(id, instance);\n\n    // Вызываем хук created\n    try {\n      component.created?.call(instance);\n    } catch (error) {\n      console.error(`Ошибка в хуке created компонента \"${componentName}\":`, error);\n    }\n\n    return instance;\n  }\n\n  /**\n   * Получение экземпляра по ID\n   */\n  getInstance(id: string): ComponentInstance | undefined {\n    return this.instances.get(id);\n  }\n\n  /**\n   * Удаление экземпляра\n   */\n  destroyInstance(id: string): boolean {\n    const instance = this.instances.get(id);\n    if (!instance) {\n      return false;\n    }\n\n    // Размонтируем если смонтирован\n    if (instance.mounted && instance.element) {\n      this.unmountInstance(instance);\n    }\n\n    // Вызываем хук destroyed\n    try {\n      instance.component.destroyed?.call(instance);\n    } catch (error) {\n      console.error(`Ошибка в хуке destroyed компонента \"${instance.component.name}\":`, error);\n    }\n\n    // Очищаем ссылки\n    instance.dependencies.clear();\n    instance.children.forEach(child => {\n      child.parent = null;\n    });\n\n    return this.instances.delete(id);\n  }\n\n  /**\n   * Монтирование экземпляра с полным жизненным циклом\n   */\n  mountInstance(instance: ComponentInstance, element: HTMLElement): void {\n    if (instance.mounted) {\n      console.warn(`Экземпляр ${instance.id} уже смонтирован`);\n      return;\n    }\n\n    // Вызываем хук beforeMount\n    try {\n      instance.component.beforeMount?.call(instance);\n    } catch (error) {\n      console.error(`Ошибка в хуке beforeMount компонента \"${instance.component.name}\":`, error);\n    }\n\n    instance.element = element;\n    instance.mounted = true;\n\n    // Вызываем хук mounted\n    try {\n      instance.component.mounted?.call(instance);\n    } catch (error) {\n      console.error(`Ошибка в хуке mounted компонента \"${instance.component.name}\":`, error);\n    }\n  }\n\n  /**\n   * Размонтирование экземпляра с вызовом хуков\n   */\n  unmountInstance(instance: ComponentInstance): void {\n    if (!instance.mounted) {\n      return;\n    }\n\n    // Вызываем хук beforeDestroy\n    try {\n      instance.component.beforeDestroy?.call(instance);\n    } catch (error) {\n      console.error(`Ошибка в хуке beforeDestroy компонента \"${instance.component.name}\":`, error);\n    }\n\n    // Размонтируем дочерние компоненты\n    instance.children.forEach(child => {\n      this.unmountInstance(child);\n    });\n\n    // Очищаем ресурсы\n    instance.cleanup.forEach(cleanupFn => {\n      try {\n        cleanupFn();\n      } catch (error) {\n        console.error('Ошибка при очистке ресурсов:', error);\n      }\n    });\n\n    instance.element = null;\n    instance.mounted = false;\n\n    // Вызываем хук destroyed\n    try {\n      instance.component.destroyed?.call(instance);\n    } catch (error) {\n      console.error(`Ошибка в хуке destroyed компонента \"${instance.component.name}\":`, error);\n    }\n  }\n\n  /**\n   * Обновление props экземпляра с хуками жизненного цикла\n   */\n  updateInstanceProps(instance: ComponentInstance, newProps: any): void {\n    const component = instance.component;\n    const validatedProps = this.validateAndNormalizeProps(newProps, component.props);\n    \n    // Определяем изменившиеся props\n    const changedProps: string[] = [];\n    for (const key in validatedProps) {\n      if (instance.props[key] !== validatedProps[key]) {\n        changedProps.push(key);\n      }\n    }\n\n    if (changedProps.length === 0) {\n      return; // Ничего не изменилось\n    }\n\n    // Вызываем хук beforeUpdate\n    try {\n      component.beforeUpdate?.call(instance, changedProps, []);\n    } catch (error) {\n      console.error(`Ошибка в хуке beforeUpdate компонента \"${component.name}\":`, error);\n    }\n\n    // Обновляем props\n    instance.props = validatedProps;\n\n    // Вызываем хук updated\n    try {\n      component.updated?.call(instance, changedProps, []);\n    } catch (error) {\n      console.error(`Ошибка в хуке updated компонента \"${component.name}\":`, error);\n    }\n  }\n\n  /**\n   * Получение всех экземпляров компонента\n   */\n  getInstancesByComponent(componentName: string): ComponentInstance[] {\n    return Array.from(this.instances.values())\n      .filter(instance => instance.component.name === componentName);\n  }\n\n  /**\n   * Получение всех смонтированных экземпляров\n   */\n  getMountedInstances(): ComponentInstance[] {\n    return Array.from(this.instances.values())\n      .filter(instance => instance.mounted);\n  }\n\n  /**\n   * Очистка всех экземпляров\n   */\n  clearInstances(): void {\n    // Размонтируем все экземпляры\n    Array.from(this.instances.values()).forEach(instance => {\n      this.destroyInstance(instance.id);\n    });\n  }\n\n  /**\n   * Очистка всего реестра\n   */\n  clear(): void {\n    this.clearInstances();\n    this.components.clear();\n  }\n\n  /**\n   * Получение списка всех зарегистрированных компонентов\n   */\n  getRegisteredComponents(): string[] {\n    return Array.from(this.components.keys());\n  }\n\n  /**\n   * Получение статистики\n   */\n  getStats() {\n    const mountedCount = this.getMountedInstances().length;\n    return {\n      registeredComponents: this.components.size,\n      totalInstances: this.instances.size,\n      mountedInstances: mountedCount,\n      unmountedInstances: this.instances.size - mountedCount\n    };\n  }\n\n  /**\n   * Валидация определения компонента\n   */\n  private validateComponent(component: Component): void {\n    if (typeof component.render !== 'function') {\n      throw new Error(`Компонент \"${component.name}\" должен иметь функцию render`);\n    }\n\n    if (component.props) {\n      for (const [propName, propDef] of Object.entries(component.props)) {\n        if (!this.isValidPropDefinition(propDef)) {\n          throw new Error(\n            `Некорректное определение свойства \"${propName}\" в компоненте \"${component.name}\"`\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Проверка корректности определения свойства\n   */\n  private isValidPropDefinition(propDef: PropDefinition): boolean {\n    const validTypes = ['string', 'number', 'boolean', 'object', 'array', 'function'];\n    return validTypes.includes(propDef.type);\n  }\n\n  /**\n   * Валидация и нормализация props\n   */\n  private validateAndNormalizeProps(props: any, propDefinitions?: any): any {\n    if (!propDefinitions) {\n      return props || {};\n    }\n\n    const result: any = {};\n\n    // Обрабатываем каждое определение свойства\n    for (const [propName, propDef] of Object.entries(propDefinitions as Record<string, PropDefinition>)) {\n      const value = props[propName];\n\n      // Проверяем обязательные свойства\n      if (propDef.required && (value === undefined || value === null)) {\n        throw new Error(`Обязательное свойство \"${propName}\" не передано`);\n      }\n\n      // Используем значение по умолчанию\n      if (value === undefined) {\n        result[propName] = propDef.default;\n        continue;\n      }\n\n      // Валидация типа\n      if (!this.validatePropType(value, propDef.type)) {\n        throw new Error(\n          `Свойство \"${propName}\" должно быть типа ${propDef.type}, получено ${typeof value}`\n        );\n      }\n\n      // Кастомная валидация\n      if (propDef.validator && !propDef.validator(value)) {\n        throw new Error(`Свойство \"${propName}\" не прошло кастомную валидацию`);\n      }\n\n      result[propName] = value;\n    }\n\n    return result;\n  }\n\n  /**\n   * Валидация типа свойства\n   */\n  private validatePropType(value: any, expectedType: string): boolean {\n    switch (expectedType) {\n      case 'string':\n        return typeof value === 'string';\n      case 'number':\n        return typeof value === 'number' && !isNaN(value);\n      case 'boolean':\n        return typeof value === 'boolean';\n      case 'function':\n        return typeof value === 'function';\n      case 'object':\n        return value !== null && typeof value === 'object' && !Array.isArray(value);\n      case 'array':\n        return Array.isArray(value);\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Генерация уникального ID для экземпляра\n   */\n  private generateInstanceId(): string {\n    return `component_${++this.instanceCounter}_${Date.now()}`;\n  }\n}\n\n/**\n * Глобальный экземпляр реестра компонентов\n */\nexport const componentRegistry = new ComponentRegistry();\n\n/**\n * Удобные функции для работы с реестром\n */\n\n/**\n * Регистрация компонента\n */\nexport function registerComponent(component: Component): void {\n  componentRegistry.register(component);\n}\n\n/**\n * Получение компонента\n */\nexport function getComponent(name: string): Component | undefined {\n  return componentRegistry.get(name);\n}\n\n/**\n * Создание экземпляра компонента\n */\nexport function createComponentInstance(name: string, props?: any): ComponentInstance {\n  return componentRegistry.createInstance(name, props);\n}","import { ReactiveEffect } from './types';\n\n/**\n * Очередь обновлений для предотвращения избыточных рендеров\n */\nclass UpdateScheduler {\n  private updateQueue = new Set<Function>();\n  private isFlushPending = false;\n  private isFlushActive = false;\n  private currentFlushPromise: Promise<void> | null = null;\n  \n  /**\n   * Планирование выполнения эффекта\n   */\n  schedule(effect: ReactiveEffect | Function): void {\n    const fn = typeof effect === 'function' ? effect : effect.fn;\n    \n    // Добавляем в очередь\n    this.updateQueue.add(fn);\n    \n    // Запускаем flush если еще не запущен\n    if (!this.isFlushPending && !this.isFlushActive) {\n      this.isFlushPending = true;\n      this.currentFlushPromise = this.scheduleFlush();\n    }\n  }\n  \n  /**\n   * Планирование обновления (алиас для schedule)\n   */\n  scheduleUpdate(fn: Function): void {\n    this.schedule(fn);\n  }\n  \n  /**\n   * Планирование выполнения flush через requestAnimationFrame\n   */\n  private scheduleFlush(): Promise<void> {\n    return new Promise<void>((resolve) => {\n      requestAnimationFrame(() => {\n        this.flushUpdates();\n        resolve();\n      });\n    });\n  }\n  \n  /**\n   * Выполнение всех запланированных обновлений\n   */\n  private flushUpdates(): void {\n    if (this.isFlushActive) {\n      return;\n    }\n    \n    this.isFlushActive = true;\n    this.isFlushPending = false;\n    \n    try {\n      // Получаем копию очереди и очищаем оригинал\n      const effects = Array.from(this.updateQueue);\n      this.updateQueue.clear();\n      \n      // Выполняем все обновления в одном батче\n      for (const effect of effects) {\n        try {\n          effect();\n        } catch (error) {\n          console.error('Ошибка при выполнении запланированного эффекта:', error);\n          // Продолжаем выполнение остальных эффектов\n        }\n      }\n      \n      // Если во время выполнения появились новые эффекты, планируем следующий flush\n      if (this.updateQueue.size > 0 && !this.isFlushPending) {\n        this.isFlushPending = true;\n        this.currentFlushPromise = this.scheduleFlush();\n      }\n    } finally {\n      this.isFlushActive = false;\n      if (this.updateQueue.size === 0) {\n        this.currentFlushPromise = null;\n      }\n    }\n  }\n  \n  /**\n   * Ожидание завершения всех запланированных обновлений\n   */\n  async nextTick(): Promise<void> {\n    if (this.currentFlushPromise) {\n      await this.currentFlushPromise;\n    }\n    \n    // Если после ожидания снова появились задачи, ждем их тоже\n    if (this.currentFlushPromise) {\n      await this.nextTick();\n    }\n  }\n  \n  /**\n   * Немедленное выполнение всех запланированных обновлений\n   */\n  flushSync(): void {\n    if (this.updateQueue.size > 0) {\n      this.flushUpdates();\n    }\n  }\n  \n  /**\n   * Очистка планировщика\n   */\n  clear(): void {\n    this.updateQueue.clear();\n    this.isFlushPending = false;\n    this.isFlushActive = false;\n    this.currentFlushPromise = null;\n  }\n  \n  /**\n   * Получение размера очереди (для отладки)\n   */\n  getQueueSize(): number {\n    return this.updateQueue.size;\n  }\n  \n  /**\n   * Проверка активности планировщика\n   */\n  isActive(): boolean {\n    return this.isFlushActive || this.isFlushPending;\n  }\n}\n\n/**\n * Глобальный экземпляр планировщика\n */\nexport const scheduler = new UpdateScheduler();\n\n/**\n * Удобные функции для работы с планировщиком\n */\n\n/**\n * Планирование выполнения функции в следующем кадре\n */\nexport function nextTick(): Promise<void>;\nexport function nextTick(callback: () => void): void;\nexport function nextTick(callback?: () => void): Promise<void> | void {\n  if (callback) {\n    scheduler.nextTick().then(callback);\n  } else {\n    return scheduler.nextTick();\n  }\n}\n\n/**\n * Немедленное выполнение всех запланированных обновлений\n */\nexport function flushSync(): void {\n  scheduler.flushSync();\n}\n\n/**\n * Планирование выполнения функции\n */\nexport function scheduleUpdate(fn: Function): void {\n  scheduler.schedule(fn);\n}\n\n/**\n * Создание планировщика с приоритетами\n */\nexport class PriorityScheduler {\n  private highPriorityQueue: Function[] = [];\n  private normalPriorityQueue: Function[] = [];\n  private lowPriorityQueue: Function[] = [];\n  private isFlushPending = false;\n  \n  /**\n   * Планирование с приоритетом\n   */\n  schedule(fn: Function, priority: 'high' | 'normal' | 'low' = 'normal'): void {\n    switch (priority) {\n      case 'high':\n        this.highPriorityQueue.push(fn);\n        break;\n      case 'low':\n        this.lowPriorityQueue.push(fn);\n        break;\n      default:\n        this.normalPriorityQueue.push(fn);\n    }\n    \n    if (!this.isFlushPending) {\n      this.isFlushPending = true;\n      requestAnimationFrame(() => this.flush());\n    }\n  }\n  \n  /**\n   * Выполнение очередей по приоритету\n   */\n  private flush(): void {\n    this.isFlushPending = false;\n    \n    // Сначала выполняем высокий приоритет\n    this.executeQueue(this.highPriorityQueue);\n    \n    // Затем обычный приоритет  \n    this.executeQueue(this.normalPriorityQueue);\n    \n    // В конце низкий приоритет (с ограничением времени)\n    this.executeQueueWithTimeSlicing(this.lowPriorityQueue);\n  }\n  \n  /**\n   * Выполнение очереди\n   */\n  private executeQueue(queue: Function[]): void {\n    while (queue.length > 0) {\n      const fn = queue.shift()!;\n      try {\n        fn();\n      } catch (error) {\n        console.error('Ошибка при выполнении задачи:', error);\n      }\n    }\n  }\n  \n  /**\n   * Выполнение очереди с ограничением времени\n   */\n  private executeQueueWithTimeSlicing(queue: Function[]): void {\n    const startTime = performance.now();\n    const timeSlice = 5; // 5мс на выполнение низкоприоритетных задач\n    \n    while (queue.length > 0 && (performance.now() - startTime) < timeSlice) {\n      const fn = queue.shift()!;\n      try {\n        fn();\n      } catch (error) {\n        console.error('Ошибка при выполнении задачи:', error);\n      }\n    }\n    \n    // Если остались задачи, планируем их на следующий кадр\n    if (queue.length > 0 && !this.isFlushPending) {\n      this.isFlushPending = true;\n      requestAnimationFrame(() => this.flush());\n    }\n  }\n}","import { ElementConfig, ElementChild, DirectiveContext } from './types';\n\n/**\n * Базовый класс для директив\n */\nabstract class BaseDirective {\n  abstract name: string;\n  abstract process(config: ElementConfig, context: DirectiveContext): ElementConfig | ElementConfig[] | null;\n}\n\n/**\n * Директива условного рендеринга v-if\n */\nclass IfDirective extends BaseDirective {\n  name = 'if';\n\n  process(config: ElementConfig, context: DirectiveContext): ElementConfig | null {\n    if (!config.if) {\n      return config;\n    }\n\n    const condition = this.evaluateExpression(config.if, context);\n    \n    if (condition) {\n      // Удаляем директиву из конфига и возвращаем элемент\n      const { if: _, ...cleanConfig } = config;\n      return cleanConfig;\n    }\n\n    return null; // Элемент не рендерится\n  }\n\n  /**\n   * Безопасная оценка выражения\n   */\n  private evaluateExpression(expression: string, context: DirectiveContext): boolean {\n    try {\n      // Создаем функцию с доступом к state и props\n      const func = new Function('state', 'props', `\n        with(state) {\n          with(props) {\n            return ${expression};\n          }\n        }\n      `);\n      \n      return Boolean(func(context.state, context.props));\n    } catch (error) {\n      console.warn('Ошибка в выражении v-if:', expression, error);\n      return false;\n    }\n  }\n}\n\n/**\n * Директива рендеринга списков v-for\n */\nclass ForDirective extends BaseDirective {\n  name = 'for';\n\n  process(config: ElementConfig, context: DirectiveContext): ElementConfig[] {\n    if (!config.for || !config.template) {\n      return [config];\n    }\n\n    const { items, itemName, indexName } = this.parseForExpression(config.for);\n    const itemsArray = this.evaluateExpression(items, context);\n\n    if (!Array.isArray(itemsArray)) {\n      console.warn('v-for требует массив:', items);\n      return [];\n    }\n\n    return itemsArray.map((item, index) => {\n      const itemContext: DirectiveContext = {\n        ...context,\n        state: {\n          ...context.state,\n          [itemName]: item,\n          ...(indexName ? { [indexName]: index } : { [`${itemName}Index`]: index })\n        }\n      };\n\n      // Обрабатываем шаблон для каждого элемента\n      const processedTemplate = this.processTemplate(config.template!, itemContext);\n      \n      return {\n        ...processedTemplate,\n        key: config.key \n          ? this.evaluateExpression(String(config.key), itemContext) \n          : index\n      };\n    });\n  }\n\n  /**\n   * Парсинг выражения v-for\n   */\n  private parseForExpression(expression: string): { \n    items: string, \n    itemName: string, \n    indexName?: string \n  } {\n    // Поддерживаем синтаксис: \"item in items\" и \"(item, index) in items\"\n    const withParentheses = expression.match(/\\((\\w+),\\s*(\\w+)\\)\\s+in\\s+(.+)/);\n    if (withParentheses) {\n      return { \n        itemName: withParentheses[1], \n        indexName: withParentheses[2],\n        items: withParentheses[3] \n      };\n    }\n\n    const simple = expression.match(/(\\w+)\\s+in\\s+(.+)/);\n    if (simple) {\n      return { \n        itemName: simple[1], \n        items: simple[2] \n      };\n    }\n\n    throw new Error(`Неверный синтаксис v-for: \"${expression}\". Используйте: \"item in items\" или \"(item, index) in items\"`);\n  }\n\n  /**\n   * Обработка шаблона для элемента списка\n   */\n  private processTemplate(template: ElementConfig, context: DirectiveContext): ElementConfig {\n    // Рекурсивно обрабатываем шаблон, заменяя выражения\n    const processedTemplate = JSON.parse(JSON.stringify(template));\n    \n    // Обрабатываем содержимое (дочерние элементы)\n    if (processedTemplate.children) {\n      processedTemplate.children = processedTemplate.children.map((child: ElementChild) => {\n        if (typeof child === 'string') {\n          return this.interpolateString(child, context);\n        }\n        return this.processTemplate(child, context);\n      });\n    }\n\n    // Обрабатываем свойства\n    if (processedTemplate.props) {\n      Object.keys(processedTemplate.props).forEach(key => {\n        const value = processedTemplate.props[key];\n        if (typeof value === 'string') {\n          processedTemplate.props[key] = this.interpolateString(value, context);\n        }\n      });\n    }\n\n    return processedTemplate;\n  }\n\n  /**\n   * Интерполяция строк с выражениями {{}}\n   */\n  private interpolateString(str: string, context: DirectiveContext): string {\n    return str.replace(/\\{\\{(.+?)\\}\\}/g, (match, expression) => {\n      try {\n        const result = this.evaluateExpression(expression.trim(), context);\n        return String(result);\n      } catch (error) {\n        console.warn('Ошибка в интерполяции:', expression, error);\n        return match;\n      }\n    });\n  }\n\n  /**\n   * Оценка выражения\n   */\n  private evaluateExpression(expression: string, context: DirectiveContext): any {\n    try {\n      const func = new Function('state', 'props', `\n        with(state) {\n          with(props) {\n            return ${expression};\n          }\n        }\n      `);\n      \n      return func(context.state, context.props);\n    } catch (error) {\n      console.warn('Ошибка в выражении v-for:', expression, error);\n      return null;\n    }\n  }\n}\n\n/**\n * Директива показа/скрытия элемента v-show\n */\nclass ShowDirective extends BaseDirective {\n  name = 'show';\n\n  process(config: ElementConfig, context: DirectiveContext): ElementConfig {\n    if (config.show === undefined) {\n      return config;\n    }\n\n    const shouldShow = typeof config.show === 'boolean' \n      ? config.show \n      : this.evaluateExpression(String(config.show), context);\n\n    // Модифицируем стили для показа/скрытия\n    const processedConfig = { ...config };\n    \n    if (!processedConfig.props) {\n      processedConfig.props = {};\n    }\n\n    if (!processedConfig.props.style) {\n      processedConfig.props.style = {};\n    }\n\n    if (typeof processedConfig.props.style === 'object') {\n      processedConfig.props.style.display = shouldShow ? '' : 'none';\n    }\n\n    // Удаляем директиву из конфига\n    const { show: _, ...cleanConfig } = processedConfig;\n    return cleanConfig;\n  }\n\n  private evaluateExpression(expression: string, context: DirectiveContext): boolean {\n    try {\n      const func = new Function('state', 'props', `\n        with(state) {\n          with(props) {\n            return ${expression};\n          }\n        }\n      `);\n      \n      return Boolean(func(context.state, context.props));\n    } catch (error) {\n      console.warn('Ошибка в выражении v-show:', expression, error);\n      return false;\n    }\n  }\n}\n\n/**\n * Директива двунаправленной привязки данных v-model\n * Поддерживает все основные типы форм: input, textarea, select\n */\nclass ModelDirective extends BaseDirective {\n  name = 'model';\n  private static modelBindings = new Map<HTMLElement, { path: string; context: DirectiveContext }>();\n\n  process(config: ElementConfig, context: DirectiveContext): ElementConfig {\n    if (!config.model) {\n      return config;\n    }\n\n    const processedConfig = { ...config };\n    \n    // Инициализируем props и events если их нет\n    if (!processedConfig.props) {\n      processedConfig.props = {};\n    }\n    if (!processedConfig.events) {\n      processedConfig.events = {};\n    }\n\n    // Определяем значение и обработчик в зависимости от типа элемента\n    const tag = config.tag?.toLowerCase();\n    \n    switch (tag) {\n      case 'input':\n        this.handleInputModel(processedConfig, context);\n        break;\n      case 'textarea':\n        this.handleTextareaModel(processedConfig, context);\n        break;\n      case 'select':\n        this.handleSelectModel(processedConfig, context);\n        break;\n      default:\n        console.warn(`v-model не поддерживается для элемента ${tag}`);\n    }\n\n    // Добавляем обработчик для отслеживания элемента после рендеринга\n    const originalMounted = processedConfig.events?.mounted;\n    processedConfig.events = processedConfig.events || {};\n    processedConfig.events.mounted = (element: HTMLElement) => {\n      // Сохраняем привязку для последующих обновлений\n      ModelDirective.modelBindings.set(element, {\n        path: config.model!,\n        context\n      });\n      \n      if (originalMounted) {\n        originalMounted(element);\n      }\n    };\n\n    // Удаляем директиву из конфига\n    const { model: _, ...cleanConfig } = processedConfig;\n    return cleanConfig;\n  }\n\n  /**\n   * Обработка v-model для input\n   */\n  private handleInputModel(config: ElementConfig, context: DirectiveContext): void {\n    const propertyPath = config.model!;\n    const currentValue = this.getPropertyValue(propertyPath, context);\n    const inputType = config.props?.type || 'text';\n\n    switch (inputType) {\n      case 'checkbox':\n        config.props!.checked = currentValue;\n        config.events!.change = (event: Event) => {\n          const target = event.target as HTMLInputElement;\n          this.setPropertyValue(propertyPath, target.checked, context);\n        };\n        break;\n      \n      case 'radio':\n        config.props!.checked = currentValue === config.props?.value;\n        config.events!.change = (event: Event) => {\n          const target = event.target as HTMLInputElement;\n          if (target.checked) {\n            this.setPropertyValue(propertyPath, target.value, context);\n          }\n        };\n        break;\n      \n      default:\n        config.props!.value = currentValue;\n        config.events!.input = (event: Event) => {\n          const target = event.target as HTMLInputElement;\n          this.setPropertyValue(propertyPath, target.value, context);\n        };\n    }\n  }\n\n  /**\n   * Обработка v-model для textarea\n   */\n  private handleTextareaModel(config: ElementConfig, context: DirectiveContext): void {\n    const propertyPath = config.model!;\n    const currentValue = this.getPropertyValue(propertyPath, context);\n\n    config.props!.value = currentValue;\n    config.events!.input = (event: Event) => {\n      const target = event.target as HTMLTextAreaElement;\n      this.setPropertyValue(propertyPath, target.value, context);\n    };\n  }\n\n  /**\n   * Обработка v-model для select\n   */\n  private handleSelectModel(config: ElementConfig, context: DirectiveContext): void {\n    const propertyPath = config.model!;\n    const currentValue = this.getPropertyValue(propertyPath, context);\n\n    config.props!.value = currentValue;\n    config.events!.change = (event: Event) => {\n      const target = event.target as HTMLSelectElement;\n      this.setPropertyValue(propertyPath, target.value, context);\n    };\n  }\n\n  /**\n   * Получение значения свойства по пути\n   */\n  private getPropertyValue(path: string, context: DirectiveContext): any {\n    try {\n      const func = new Function('state', 'props', `\n        with(state) {\n          with(props) {\n            return ${path};\n          }\n        }\n      `);\n      \n      return func(context.state, context.props);\n    } catch (error) {\n      console.warn('Ошибка при получении значения v-model:', path, error);\n      return '';\n    }\n  }\n\n  /**\n   * Установка значения свойства по пути с поддержкой реактивности\n   */\n  private setPropertyValue(path: string, value: any, context: DirectiveContext): void {\n    try {\n      // Поддерживаем различные пути: property, nested.property, array[0].property\n      const pathParts = this.parsePath(path);\n      let obj = context.state;\n      \n      // Навигируемся до последнего объекта\n      for (let i = 0; i < pathParts.length - 1; i++) {\n        const part = pathParts[i];\n        if (part.type === 'property') {\n          obj = obj[part.key];\n        } else if (part.type === 'index') {\n          obj = obj[part.key];\n        }\n      }\n      \n      // Устанавливаем значение\n      const lastPart = pathParts[pathParts.length - 1];\n      if (lastPart.type === 'property') {\n        obj[lastPart.key] = value;\n      } else if (lastPart.type === 'index') {\n        obj[lastPart.key] = value;\n      }\n      \n      // Запускаем обновление интерфейса через планировщик\n      this.triggerUpdate(context);\n      \n    } catch (error) {\n      console.warn('Ошибка при установке значения v-model:', path, error);\n    }\n  }\n  \n  /**\n   * Парсинг пути для поддержки сложных выражений\n   */\n  private parsePath(path: string): Array<{ type: 'property' | 'index'; key: string | number }> {\n    const parts: Array<{ type: 'property' | 'index'; key: string | number }> = [];\n    \n    // Упрощенный парсер для основных случаев\n    const segments = path.split('.');\n    \n    for (const segment of segments) {\n      const arrayMatch = segment.match(/^(\\w+)\\[(\\d+)\\]$/);\n      if (arrayMatch) {\n        parts.push({ type: 'property', key: arrayMatch[1] });\n        parts.push({ type: 'index', key: parseInt(arrayMatch[2]) });\n      } else {\n        parts.push({ type: 'property', key: segment });\n      }\n    }\n    \n    return parts;\n  }\n  \n  /**\n   * Запуск обновления через планировщик\n   */\n  private triggerUpdate(context: DirectiveContext): void {\n    // Импортируем планировщик динамически чтобы избежать циклических зависимостей\n    import('./scheduler').then(({ scheduler }) => {\n      scheduler.scheduleUpdate(() => {\n        // Обновление будет обработано планировщиком\n      });\n    }).catch(error => {\n      console.warn('Ошибка при запуске обновления:', error);\n    });\n  }\n  \n  /**\n   * Статический метод для обновления всех привязанных элементов\n   */\n  static updateBoundElements(): void {\n    for (const [element, binding] of ModelDirective.modelBindings) {\n      try {\n        const currentValue = new ModelDirective().getPropertyValue(binding.path, binding.context);\n        \n        if (element instanceof HTMLInputElement) {\n          if (element.type === 'checkbox' || element.type === 'radio') {\n            element.checked = element.type === 'checkbox' ? currentValue : (currentValue === element.value);\n          } else {\n            element.value = String(currentValue || '');\n          }\n        } else if (element instanceof HTMLTextAreaElement) {\n          element.value = String(currentValue || '');\n        } else if (element instanceof HTMLSelectElement) {\n          element.value = String(currentValue || '');\n        }\n      } catch (error) {\n        console.warn('Ошибка при обновлении привязанного элемента:', error);\n      }\n    }\n  }\n}\n\n/**\n * Менеджер директив\n */\nexport class DirectiveManager {\n  private directives = new Map<string, BaseDirective>();\n\n  constructor() {\n    // Регистрируем встроенные директивы\n    this.register(new IfDirective());\n    this.register(new ForDirective());\n    this.register(new ShowDirective());\n    this.register(new ModelDirective());\n  }\n\n  /**\n   * Регистрация новой директивы\n   */\n  register(directive: BaseDirective): void {\n    this.directives.set(directive.name, directive);\n  }\n\n  /**\n   * Обработка всех директив в конфигурации\n   */\n  processDirectives(config: ElementConfig, context: DirectiveContext): ElementConfig[] {\n    let results: ElementConfig[] = [config];\n\n    // Обрабатываем директивы в определенном порядке\n    const directiveOrder = ['if', 'for', 'show', 'model'];\n\n    for (const directiveName of directiveOrder) {\n      const directive = this.directives.get(directiveName);\n      if (!directive) continue;\n\n      const newResults: ElementConfig[] = [];\n\n      for (const configItem of results) {\n        const processed = directive.process(configItem, context);\n        \n        if (processed) {\n          if (Array.isArray(processed)) {\n            newResults.push(...processed);\n          } else {\n            newResults.push(processed);\n          }\n        }\n      }\n\n      results = newResults;\n    }\n\n    return results;\n  }\n\n  /**\n   * Проверка наличия директив в конфигурации\n   */\n  hasDirectives(config: ElementConfig): boolean {\n    return !!(config.if || config.for || config.show !== undefined || config.model);\n  }\n}\n\n/**\n * Глобальный экземпляр менеджера директив\n */\nexport const directiveManager = new DirectiveManager();\n\n// Экспорт отдельных директив для прямого использования\nexport { IfDirective, ForDirective, ShowDirective, ModelDirective };","import { \n  ElementConfig, \n  ElementProps, \n  EventHandlers, \n  ComponentInstance,\n  DirectiveContext,\n  RenderStats\n} from './types';\nimport { componentRegistry } from './component-registry';\nimport { effect } from './reactive';\nimport { scheduler } from './scheduler';\nimport { directiveManager } from './directives';\n\n/**\n * Расширенный рендерер с поддержкой компонентов и реактивности\n */\nexport class ComponentRenderer {\n  private mountedInstances = new Map<HTMLElement, ComponentInstance>();\n  private instanceElements = new Map<string, HTMLElement>();\n  private stats: RenderStats = {\n    elementsCreated: 0,\n    eventsAttached: 0,\n    renderTime: 0\n  };\n\n  /**\n   * Основной метод рендеринга\n   */\n  render(config: ElementConfig, container: HTMLElement): HTMLElement {\n    const startTime = performance.now();\n    \n    try {\n      // Очищаем контейнер\n      this.clearContainer(container);\n      \n      // Рендерим конфигурацию\n      const element = this.renderConfig(config);\n      container.appendChild(element);\n      \n      this.stats.renderTime = performance.now() - startTime;\n      return element;\n    } catch (error) {\n      console.error('Ошибка рендеринга:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Рендеринг конфигурации (элемент или компонент)\n   */\n  private renderConfig(config: ElementConfig, parentInstance?: ComponentInstance): HTMLElement {\n    // Проверяем, является ли это компонентом\n    if (config.component) {\n      return this.renderComponent(config, parentInstance);\n    } else {\n      return this.renderElement(config, parentInstance);\n    }\n  }\n\n  /**\n   * Рендеринг компонента\n   */\n  private renderComponent(config: ElementConfig, parentInstance?: ComponentInstance): HTMLElement {\n    const componentName = config.component!;\n    \n    // Создаем экземпляр компонента\n    const instance = componentRegistry.createInstance(componentName, config.props);\n    \n    // Устанавливаем родительскую связь\n    if (parentInstance) {\n      instance.parent = parentInstance;\n      parentInstance.children.push(instance);\n    }\n\n    // Создаем контекст для директив\n    const directiveContext: DirectiveContext = {\n      state: instance.state,\n      props: instance.props,\n      instance,\n      computed: instance.computed\n    };\n\n    // Создаем реактивный эффект для перерендеринга\n    effect(() => {\n      try {\n        // Получаем конфигурацию от компонента с computed свойствами\n        const componentConfig = instance.component.render.call(\n          instance,\n          instance.props, \n          instance.state, \n          instance.computed\n        );\n        \n        // Обрабатываем директивы\n        const processedConfigs = directiveManager.processDirectives(componentConfig, directiveContext);\n        \n        if (processedConfigs.length === 0) {\n          // Компонент скрыт директивой\n          if (instance.element) {\n            this.unmountComponent(instance);\n          }\n          return;\n        }\n\n        // Рендерим первый результат (в большинстве случаев будет только один)\n        const newElement = this.renderElement(processedConfigs[0], instance);\n        \n        if (instance.element) {\n          // Обновляем существующий элемент\n          if (instance.element.parentNode) {\n            instance.element.parentNode.replaceChild(newElement, instance.element);\n          }\n          instance.element = newElement;\n        } else {\n          // Первый рендер\n          instance.element = newElement;\n          this.instanceElements.set(instance.id, newElement);\n          this.mountedInstances.set(newElement, instance);\n          \n          // Вызываем хук onMount\n          componentRegistry.mountInstance(instance, newElement);\n        }\n      } catch (error) {\n        console.error('Ошибка при рендеринге компонента:', error);\n      }\n    }, {\n      scheduler: (effect) => scheduler.schedule(effect)\n    });\n\n    // Возвращаем элемент (он будет создан в эффекте)\n    return instance.element || this.createPlaceholder();\n  }\n\n  /**\n   * Рендеринг обычного элемента\n   */\n  private renderElement(config: ElementConfig, parentInstance?: ComponentInstance): HTMLElement {\n    // Создаем контекст для директив\n    const directiveContext: DirectiveContext = {\n      state: parentInstance?.state || {},\n      props: parentInstance?.props || {},\n      instance: parentInstance || undefined,\n      computed: parentInstance?.computed || {}\n    };\n\n    // Обрабатываем директивы\n    const processedConfigs = directiveManager.processDirectives(config, directiveContext);\n    \n    if (processedConfigs.length === 0) {\n      return this.createPlaceholder();\n    }\n\n    // Для простоты берем первый результат\n    const processedConfig = processedConfigs[0];\n    \n    // Создаем HTML элемент\n    const element = document.createElement(processedConfig.tag || 'div');\n    this.stats.elementsCreated++;\n\n    // Применяем свойства\n    if (processedConfig.props) {\n      this.applyProps(element, processedConfig.props);\n    }\n\n    // Привязываем события\n    if (processedConfig.events) {\n      this.attachEvents(element, processedConfig.events);\n    }\n\n    // Рендерим дочерние элементы\n    if (processedConfig.children) {\n      this.renderChildren(element, processedConfig.children, parentInstance);\n    }\n\n    return element;\n  }\n\n  /**\n   * Рендеринг дочерних элементов\n   */\n  private renderChildren(\n    parent: HTMLElement, \n    children: any[], \n    parentInstance?: ComponentInstance\n  ): void {\n    children.forEach(child => {\n      if (typeof child === 'string') {\n        // Текстовый узел\n        const textNode = document.createTextNode(child);\n        parent.appendChild(textNode);\n      } else if (child && typeof child === 'object') {\n        // Вложенный элемент или компонент\n        const childElement = this.renderConfig(child, parentInstance);\n        parent.appendChild(childElement);\n      }\n    });\n  }\n\n  /**\n   * Применение свойств к элементу\n   */\n  private applyProps(element: HTMLElement, props: ElementProps): void {\n    for (const [key, value] of Object.entries(props)) {\n      switch (key) {\n        case 'class':\n          element.className = value as string;\n          break;\n        case 'id':\n          element.id = value as string;\n          break;\n        case 'style':\n          this.applyStyles(element, value as any);\n          break;\n        default:\n          if (value !== undefined && value !== null) {\n            element.setAttribute(key, String(value));\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * Применение стилей\n   */\n  private applyStyles(element: HTMLElement, styles: any): void {\n    if (typeof styles === 'object') {\n      for (const [property, value] of Object.entries(styles)) {\n        if (value !== undefined && value !== null) {\n          const cssProperty = property.replace(/([A-Z])/g, '-$1').toLowerCase();\n          element.style.setProperty(cssProperty, String(value));\n        }\n      }\n    } else if (typeof styles === 'string') {\n      element.style.cssText = styles;\n    }\n  }\n\n  /**\n   * Привязка обработчиков событий\n   */\n  private attachEvents(element: HTMLElement, events: EventHandlers): void {\n    for (const [eventType, handler] of Object.entries(events)) {\n      if (!handler) continue; // Пропускаем undefined обработчики\n      \n      // Обрабатываем кастомные события\n      if (eventType === 'mounted' || eventType === 'unmounted') {\n        // Кастомные события - вызываем напрямую\n        if (eventType === 'mounted') {\n          (handler as (element: HTMLElement) => void)(element);\n        }\n        continue;\n      }\n      \n      element.addEventListener(eventType, handler as EventListener);\n      this.stats.eventsAttached++;\n    }\n  }\n\n  /**\n   * Размонтирование компонента\n   */\n  private unmountComponent(instance: ComponentInstance): void {\n    if (instance.element) {\n      // Удаляем элемент из DOM\n      if (instance.element.parentNode) {\n        instance.element.parentNode.removeChild(instance.element);\n      }\n\n      // Очищаем ссылки\n      this.mountedInstances.delete(instance.element);\n      this.instanceElements.delete(instance.id);\n      \n      // Размонтируем через реестр\n      componentRegistry.unmountInstance(instance);\n    }\n  }\n\n  /**\n   * Создание элемента-заглушки\n   */\n  private createPlaceholder(): HTMLElement {\n    const placeholder = document.createElement('span');\n    placeholder.style.display = 'none';\n    placeholder.setAttribute('data-placeholder', 'true');\n    return placeholder;\n  }\n\n  /**\n   * Очистка контейнера\n   */\n  private clearContainer(container: HTMLElement): void {\n    // Размонтируем все компоненты в контейнере\n    const instances = Array.from(this.mountedInstances.entries())\n      .filter(([element]) => container.contains(element))\n      .map(([, instance]) => instance);\n\n    instances.forEach(instance => {\n      componentRegistry.destroyInstance(instance.id);\n    });\n\n    // Очищаем содержимое\n    container.innerHTML = '';\n  }\n\n  /**\n   * Обновление существующего элемента новой конфигурацией\n   */\n  updateElement(element: HTMLElement, newConfig: ElementConfig): HTMLElement {\n    const instance = this.mountedInstances.get(element);\n    \n    if (instance) {\n      // Обновляем компонент\n      if (newConfig.props) {\n        componentRegistry.updateInstanceProps(instance, newConfig.props);\n      }\n      return instance.element || element;\n    } else {\n      // Обновляем обычный элемент\n      const newElement = this.renderConfig(newConfig);\n      if (element.parentNode) {\n        element.parentNode.replaceChild(newElement, element);\n      }\n      return newElement;\n    }\n  }\n\n  /**\n   * Размонтирование элемента\n   */\n  unmount(element: HTMLElement): void {\n    const instance = this.mountedInstances.get(element);\n    \n    if (instance) {\n      // Размонтируем компонент\n      componentRegistry.destroyInstance(instance.id);\n    } else {\n      // Удаляем обычный элемент\n      if (element.parentNode) {\n        element.parentNode.removeChild(element);\n      }\n    }\n  }\n\n  /**\n   * Поиск компонента по элементу\n   */\n  getComponentInstance(element: HTMLElement): ComponentInstance | undefined {\n    return this.mountedInstances.get(element);\n  }\n\n  /**\n   * Получение статистики\n   */\n  getStats(): RenderStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Очистка всех ресурсов\n   */\n  cleanup(): void {\n    // Размонтируем все компоненты\n    this.mountedInstances.forEach(instance => {\n      componentRegistry.destroyInstance(instance.id);\n    });\n\n    this.mountedInstances.clear();\n    this.instanceElements.clear();\n    \n    // Сбрасываем статистику\n    this.stats = {\n      elementsCreated: 0,\n      eventsAttached: 0,\n      renderTime: 0\n    };\n  }\n\n  /**\n   * Принудительное обновление всех компонентов\n   */\n  forceUpdate(): void {\n    scheduler.flushSync();\n  }\n\n  /**\n   * Поиск элемента по ID\n   */\n  findElementById(element: HTMLElement, id: string): HTMLElement | null {\n    return element.querySelector(`#${id}`);\n  }\n\n  /**\n   * Поиск элементов по классу\n   */\n  findElementsByClass(element: HTMLElement, className: string): HTMLElement[] {\n    return Array.from(element.querySelectorAll(`.${className}`));\n  }\n}","import { effect, stop, ReactiveEffect } from './reactive';\nimport { scheduler } from './scheduler';\nimport { EffectOptions } from './types';\n\n/**\n * Вспомогательная функция для запуска эффекта\n */\nfunction runEffect(effect: ReactiveEffect): any {\n  if (!effect.active) {\n    return effect.fn();\n  }\n  return effect.fn();\n}\n\n/**\n * Интерфейс для computed свойства\n */\nexport interface ComputedRef<T = any> {\n  readonly value: T;\n  readonly dirty: boolean;\n  readonly effect: ReactiveEffect;\n}\n\n/**\n * Опции для computed свойства\n */\nexport interface ComputedOptions {\n  /** Функция для получения значения */\n  get: () => any;\n  /** Функция для установки значения (опционально) */\n  set?: (value: any) => void;\n  /** Включить отладку */\n  debug?: boolean;\n}\n\n/**\n * Внутренняя реализация computed свойства\n */\nclass ComputedRefImpl<T> implements ComputedRef<T> {\n  private _value!: T;\n  private _dirty = true;\n  private _effect: ReactiveEffect;\n  private _setter?: (value: any) => void;\n\n  constructor(getter: () => T, setter?: (value: any) => void) {\n    this._setter = setter;\n    \n    // Создаем эффект который будет отслеживать зависимости\n    this._effect = effect(() => getter(), {\n      lazy: true,\n      scheduler: () => {\n        // Когда зависимости изменяются, помечаем как \"грязное\"\n        if (!this._dirty) {\n          this._dirty = true;\n          // Уведомляем о изменении computed свойства\n          this.triggerUpdate();\n        }\n      }\n    });\n  }\n\n  get value(): T {\n    // Если значение \"грязное\", пересчитываем его\n    if (this._dirty) {\n      this._value = runEffect(this._effect);\n      this._dirty = false;\n    }\n    return this._value;\n  }\n\n  set value(newValue: T) {\n    if (this._setter) {\n      this._setter(newValue);\n    } else {\n      console.warn('Computed свойство доступно только для чтения');\n    }\n  }\n\n  get dirty(): boolean {\n    return this._dirty;\n  }\n\n  get effect(): ReactiveEffect {\n    return this._effect;\n  }\n\n  /**\n   * Принудительное обновление computed свойства\n   */\n  invalidate(): void {\n    this._dirty = true;\n    this.triggerUpdate();\n  }\n\n  /**\n   * Уведомление об изменении computed свойства\n   */\n  private triggerUpdate(): void {\n    scheduler.scheduleUpdate(() => {\n      // Обновление будет обработано планировщиком\n    });\n  }\n\n  /**\n   * Остановка отслеживания зависимостей\n   */\n  stop(): void {\n    stop(this._effect);\n  }\n}\n\n/**\n * Создание computed свойства с функцией-геттером\n */\nexport function computed<T>(getter: () => T): ComputedRef<T>;\n\n/**\n * Создание computed свойства с геттером и сеттером\n */\nexport function computed<T>(options: ComputedOptions): ComputedRef<T>;\n\n/**\n * Реализация функции computed\n */\nexport function computed<T>(getterOrOptions: (() => T) | ComputedOptions): ComputedRef<T> {\n  let getter: () => T;\n  let setter: ((value: T) => void) | undefined;\n\n  if (typeof getterOrOptions === 'function') {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n\n  return new ComputedRefImpl(getter, setter);\n}\n\n/**\n * Проверка является ли объект computed свойством\n */\nexport function isComputedRef(r: any): r is ComputedRef {\n  return !!(r && r._effect && typeof r.value !== 'undefined');\n}\n\n/**\n * Менеджер для управления computed свойствами\n */\nexport class ComputedManager {\n  private computedRefs = new Set<ComputedRefImpl<any>>();\n\n  /**\n   * Регистрация computed свойства для управления\n   */\n  register(computedRef: ComputedRefImpl<any>): void {\n    this.computedRefs.add(computedRef);\n  }\n\n  /**\n   * Удаление computed свойства из управления\n   */\n  unregister(computedRef: ComputedRefImpl<any>): void {\n    this.computedRefs.delete(computedRef);\n    computedRef.stop();\n  }\n\n  /**\n   * Принудительная валидация всех computed свойств\n   */\n  invalidateAll(): void {\n    for (const computedRef of this.computedRefs) {\n      computedRef.invalidate();\n    }\n  }\n\n  /**\n   * Получение статистики computed свойств\n   */\n  getStats(): { total: number; dirty: number; clean: number } {\n    let dirty = 0;\n    let clean = 0;\n    \n    for (const computedRef of this.computedRefs) {\n      if (computedRef.dirty) {\n        dirty++;\n      } else {\n        clean++;\n      }\n    }\n\n    return {\n      total: this.computedRefs.size,\n      dirty,\n      clean\n    };\n  }\n\n  /**\n   * Очистка всех computed свойств\n   */\n  cleanup(): void {\n    for (const computedRef of this.computedRefs) {\n      computedRef.stop();\n    }\n    this.computedRefs.clear();\n  }\n}\n\n/**\n * Глобальный экземпляр менеджера computed свойств\n */\nexport const computedManager = new ComputedManager();\n\n/**\n * Хелпер для создания computed свойства внутри компонента\n */\nexport function useComputed<T>(getter: () => T, deps?: any[]): ComputedRef<T> {\n  const computedRef = computed(getter);\n  computedManager.register(computedRef as ComputedRefImpl<T>);\n  return computedRef;\n}\n\n/**\n * Хелпер для создания вычисляемого свойства с кешированием на основе зависимостей\n */\nexport function memo<T>(fn: () => T, deps: any[]): () => T {\n  let cachedValue: T;\n  let cachedDeps: any[] = [];\n  let isInitialized = false;\n\n  return () => {\n    const hasChanged = !isInitialized || deps.some((dep, index) => dep !== cachedDeps[index]);\n    \n    if (hasChanged) {\n      cachedValue = fn();\n      cachedDeps = [...deps];\n      isInitialized = true;\n    }\n    \n    return cachedValue;\n  };\n}\n\n/**\n * Создание computed свойства для компонента с автоматической очисткой\n */\nexport function createComponentComputed<T>(\n  getter: () => T,\n  onDestroy?: () => void\n): ComputedRef<T> & { destroy: () => void } {\n  const computedRef = computed(getter) as ComputedRefImpl<T>;\n  computedManager.register(computedRef);\n\n  return {\n    get value() { return computedRef.value; },\n    get dirty() { return computedRef.dirty; },\n    get effect() { return computedRef.effect; },\n    \n    destroy() {\n      computedManager.unregister(computedRef);\n      if (onDestroy) {\n        onDestroy();\n      }\n    }\n  };\n}","import { Plugin, PluginOptions, PluginContext, CustomDirective } from './types';\n\n/**\n * Менеджер плагинов для фреймворка\n */\nclass PluginManager {\n  private plugins = new Map<string, Plugin>();\n  private installedPlugins = new Set<string>();\n  private globalProperties = new Map<string, any>();\n  private customDirectives = new Map<string, CustomDirective>();\n  private frameworkInstance: any;\n\n  constructor(framework: any) {\n    this.frameworkInstance = framework;\n  }\n\n  /**\n   * Установка плагина\n   */\n  use(plugin: Plugin, options?: PluginOptions): this {\n    // Проверяем, не установлен ли уже плагин\n    if (this.installedPlugins.has(plugin.name)) {\n      console.warn(`Плагин \"${plugin.name}\" уже установлен`);\n      return this;\n    }\n\n    // Проверяем зависимости\n    if (plugin.dependencies) {\n      for (const dependency of plugin.dependencies) {\n        if (!this.installedPlugins.has(dependency)) {\n          throw new Error(`Плагин \"${plugin.name}\" требует зависимость \"${dependency}\"`);\n        }\n      }\n    }\n\n    // Создаем контекст для плагина\n    const context: PluginContext = {\n      framework: this.frameworkInstance,\n      options: options || {},\n      globalProperties: Object.fromEntries(this.globalProperties),\n      directives: this.customDirectives\n    };\n\n    try {\n      // Вызываем функцию установки плагина\n      plugin.install(this.frameworkInstance, context);\n      \n      // Регистрируем плагин как установленный\n      this.plugins.set(plugin.name, plugin);\n      this.installedPlugins.add(plugin.name);\n      \n      console.log(`Плагин \"${plugin.name}\" успешно установлен`);\n    } catch (error) {\n      console.error(`Ошибка при установке плагина \"${plugin.name}\":`, error);\n      throw error;\n    }\n\n    return this;\n  }\n\n  /**\n   * Удаление плагина (если это поддерживается)\n   */\n  uninstall(pluginName: string): boolean {\n    if (!this.installedPlugins.has(pluginName)) {\n      console.warn(`Плагин \"${pluginName}\" не установлен`);\n      return false;\n    }\n\n    const plugin = this.plugins.get(pluginName);\n    if (plugin && typeof (plugin as any).uninstall === 'function') {\n      try {\n        (plugin as any).uninstall(this.frameworkInstance);\n        this.plugins.delete(pluginName);\n        this.installedPlugins.delete(pluginName);\n        console.log(`Плагин \"${pluginName}\" удален`);\n        return true;\n      } catch (error) {\n        console.error(`Ошибка при удалении плагина \"${pluginName}\":`, error);\n        return false;\n      }\n    }\n\n    console.warn(`Плагин \"${pluginName}\" не поддерживает удаление`);\n    return false;\n  }\n\n  /**\n   * Проверка установки плагина\n   */\n  hasPlugin(pluginName: string): boolean {\n    return this.installedPlugins.has(pluginName);\n  }\n\n  /**\n   * Получение списка установленных плагинов\n   */\n  getInstalledPlugins(): string[] {\n    return Array.from(this.installedPlugins);\n  }\n\n  /**\n   * Добавление глобального свойства\n   */\n  addGlobalProperty(name: string, value: any): void {\n    this.globalProperties.set(name, value);\n  }\n\n  /**\n   * Получение глобального свойства\n   */\n  getGlobalProperty(name: string): any {\n    return this.globalProperties.get(name);\n  }\n\n  /**\n   * Регистрация пользовательской директивы\n   */\n  registerDirective(directive: CustomDirective): void {\n    if (this.customDirectives.has(directive.name)) {\n      console.warn(`Директива \"${directive.name}\" уже зарегистрирована`);\n      return;\n    }\n\n    this.customDirectives.set(directive.name, directive);\n    console.log(`Директива \"${directive.name}\" зарегистрирована`);\n  }\n\n  /**\n   * Получение пользовательской директивы\n   */\n  getDirective(name: string): CustomDirective | undefined {\n    return this.customDirectives.get(name);\n  }\n\n  /**\n   * Получение всех пользовательских директив\n   */\n  getAllDirectives(): Map<string, CustomDirective> {\n    return new Map(this.customDirectives);\n  }\n\n  /**\n   * Очистка всех плагинов и ресурсов\n   */\n  cleanup(): void {\n    // Попытаемся удалить все плагины\n    for (const pluginName of this.installedPlugins) {\n      this.uninstall(pluginName);\n    }\n\n    // Очищаем все коллекции\n    this.plugins.clear();\n    this.installedPlugins.clear();\n    this.globalProperties.clear();\n    this.customDirectives.clear();\n  }\n}\n\n/**\n * Хелпер для создания простого плагина\n */\nexport function definePlugin(options: {\n  name: string;\n  version?: string;\n  install: (framework: any, context: PluginContext) => void;\n  uninstall?: (framework: any) => void;\n  dependencies?: string[];\n}): Plugin {\n  return {\n    name: options.name,\n    version: options.version,\n    install: options.install,\n    dependencies: options.dependencies,\n    ...(options.uninstall && { uninstall: options.uninstall })\n  };\n}\n\n/**\n * Встроенные плагины для демонстрации\n */\n\n/**\n * Плагин для логирования жизненного цикла компонентов\n */\nconst LifecycleLoggerPlugin = definePlugin({\n  name: 'LifecycleLogger',\n  version: '1.0.0',\n  install(framework: any, context: PluginContext) {\n    // Добавляем глобальное свойство для включения/выключения логирования\n    context.globalProperties.set('$logLifecycle', context.options.enabled !== false);\n\n    // Расширяем фреймворк методом для логирования\n    framework.logLifecycle = (componentName: string, hook: string, data?: any) => {\n      if (context.globalProperties.get('$logLifecycle')) {\n        console.log(`[${componentName}] ${hook}`, data || '');\n      }\n    };\n  }\n});\n\n/**\n * Плагин для валидации форм\n */\nconst FormValidationPlugin = definePlugin({\n  name: 'FormValidation',\n  version: '1.0.0',\n  install(framework: any, context: PluginContext) {\n    // Регистрируем директиву для валидации\n    const validateDirective: CustomDirective = {\n      name: 'validate',\n      bind(el: HTMLElement, binding) {\n        el.addEventListener('blur', () => {\n          const validator = binding.value;\n          if (typeof validator === 'function') {\n            const isValid = validator((el as HTMLInputElement).value);\n            el.classList.toggle('invalid', !isValid);\n            el.classList.toggle('valid', isValid);\n          }\n        });\n      }\n    };\n\n    context.directives.set('validate', validateDirective);\n\n    // Добавляем глобальные валидаторы\n    framework.validators = {\n      required: (value: any) => !!value,\n      email: (value: string) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value),\n      minLength: (min: number) => (value: string) => value.length >= min,\n      maxLength: (max: number) => (value: string) => value.length <= max,\n      pattern: (regex: RegExp) => (value: string) => regex.test(value)\n    };\n  }\n});\n\n/**\n * Плагин для интернационализации (i18n)\n */\nconst I18nPlugin = definePlugin({\n  name: 'I18n',\n  version: '1.0.0',\n  install(framework: any, context: PluginContext) {\n    const messages = context.options.messages || {};\n    let currentLocale = context.options.locale || 'ru';\n\n    // Добавляем глобальные методы для работы с переводами\n    framework.t = (key: string, params?: Record<string, any>) => {\n      const message = messages[currentLocale]?.[key] || key;\n      \n      if (params) {\n        return Object.keys(params).reduce((msg, paramKey) => {\n          return msg.replace(new RegExp(`{${paramKey}}`, 'g'), params[paramKey]);\n        }, message);\n      }\n      \n      return message;\n    };\n\n    framework.setLocale = (locale: string) => {\n      currentLocale = locale;\n    };\n\n    framework.getLocale = () => currentLocale;\n\n    // Регистрируем директиву для автоматического перевода текста\n    const i18nDirective: CustomDirective = {\n      name: 'i18n',\n      bind(el: HTMLElement, binding) {\n        const key = binding.value || el.textContent;\n        if (key) {\n          el.textContent = framework.t(key);\n        }\n      },\n      update(el: HTMLElement, binding) {\n        const key = binding.value || binding.expression;\n        if (key) {\n          el.textContent = framework.t(key);\n        }\n      }\n    };\n\n    context.directives.set('i18n', i18nDirective);\n  }\n});\n\n/**\n * Плагин для управления состоянием (простой store)\n */\nconst StorePlugin = definePlugin({\n  name: 'Store',\n  version: '1.0.0',\n  install(framework: any, context: PluginContext) {\n    const initialState = context.options.state || {};\n    const mutations = context.options.mutations || {};\n    const actions = context.options.actions || {};\n\n    // Создаем реактивное состояние\n    const state = framework.reactive(initialState);\n    \n    const store = {\n      state,\n      \n      commit(mutationName: string, payload?: any) {\n        const mutation = mutations[mutationName];\n        if (mutation) {\n          mutation(state, payload);\n        } else {\n          console.warn(`Мутация \"${mutationName}\" не найдена`);\n        }\n      },\n\n      dispatch(actionName: string, payload?: any) {\n        const action = actions[actionName];\n        if (action) {\n          return action({ state, commit: this.commit, dispatch: this.dispatch }, payload);\n        } else {\n          console.warn(`Действие \"${actionName}\" не найдено`);\n        }\n      }\n    };\n\n    // Добавляем store в глобальные свойства\n    framework.$store = store;\n    context.globalProperties.set('$store', store);\n  }\n});\n\n/**\n * Экспорт основного класса и встроенных плагинов\n */\nexport {\n  PluginManager,\n  LifecycleLoggerPlugin,\n  FormValidationPlugin,\n  I18nPlugin,\n  StorePlugin\n};","/**\n * Модуль оптимизации производительности JS фреймворка\n */\n\n/**\n * Кеш для мемоизированных функций\n */\nconst memoCache = new Map();\n\n/**\n * Мемоизация функций для улучшения производительности\n */\nexport function memoize<T extends (...args: any[]) => any>(fn: T, keyGenerator?: (...args: Parameters<T>) => string): T {\n  const cache = new Map();\n  \n  return ((...args: Parameters<T>) => {\n    const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    \n    const result = fn(...args);\n    cache.set(key, result);\n    \n    // Ограничиваем размер кеша\n    if (cache.size > 1000) {\n      const firstKey = cache.keys().next().value;\n      cache.delete(firstKey);\n    }\n    \n    return result;\n  }) as T;\n}\n\n/**\n * Debounce функция для ограничения частоты вызовов\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  \n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n\n/**\n * Throttle функция для ограничения частоты вызовов\n */\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle: boolean;\n  \n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\n/**\n * Оптимизатор рендеринга компонентов\n */\nexport class ComponentOptimizer {\n  private static instance: ComponentOptimizer;\n  private renderCache = new Map<string, any>();\n  private performanceMetrics = new Map<string, number[]>();\n  \n  static getInstance(): ComponentOptimizer {\n    if (!ComponentOptimizer.instance) {\n      ComponentOptimizer.instance = new ComponentOptimizer();\n    }\n    return ComponentOptimizer.instance;\n  }\n  \n  /**\n   * Кеширование результатов рендеринга\n   */\n  cacheRender(componentId: string, props: any, result: any): void {\n    const key = this.generateCacheKey(componentId, props);\n    this.renderCache.set(key, {\n      result,\n      timestamp: Date.now()\n    });\n    \n    // Очистка старого кеша\n    this.cleanupCache();\n  }\n  \n  /**\n   * Получение кешированного результата\n   */\n  getCachedRender(componentId: string, props: any): any {\n    const key = this.generateCacheKey(componentId, props);\n    const cached = this.renderCache.get(key);\n    \n    if (cached && (Date.now() - cached.timestamp) < 5000) { // 5 секунд TTL\n      return cached.result;\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Измерение производительности рендеринга\n   */\n  measureRenderTime(componentName: string, renderFn: () => any): any {\n    const start = performance.now();\n    const result = renderFn();\n    const end = performance.now();\n    \n    this.recordMetric(componentName, end - start);\n    \n    return result;\n  }\n  \n  /**\n   * Получение метрик производительности\n   */\n  getMetrics(): Record<string, { avg: number; min: number; max: number; count: number }> {\n    const result: any = {};\n    \n    for (const [component, times] of this.performanceMetrics) {\n      result[component] = {\n        avg: times.reduce((a, b) => a + b, 0) / times.length,\n        min: Math.min(...times),\n        max: Math.max(...times),\n        count: times.length\n      };\n    }\n    \n    return result;\n  }\n  \n  private generateCacheKey(componentId: string, props: any): string {\n    return `${componentId}:${JSON.stringify(props)}`;\n  }\n  \n  private recordMetric(componentName: string, time: number): void {\n    if (!this.performanceMetrics.has(componentName)) {\n      this.performanceMetrics.set(componentName, []);\n    }\n    \n    const times = this.performanceMetrics.get(componentName)!;\n    times.push(time);\n    \n    // Ограничиваем количество записей\n    if (times.length > 100) {\n      times.shift();\n    }\n  }\n  \n  private cleanupCache(): void {\n    const now = Date.now();\n    for (const [key, cached] of this.renderCache) {\n      if (now - cached.timestamp > 10000) { // 10 секунд\n        this.renderCache.delete(key);\n      }\n    }\n  }\n}\n\n/**\n * Оптимизация DOM операций\n */\nexport class DOMOptimizer {\n  private static batchedUpdates: (() => void)[] = [];\n  private static isScheduled = false;\n  \n  /**\n   * Батчинг DOM обновлений\n   */\n  static batchUpdate(updateFn: () => void): void {\n    this.batchedUpdates.push(updateFn);\n    \n    if (!this.isScheduled) {\n      this.isScheduled = true;\n      requestAnimationFrame(() => {\n        this.flushUpdates();\n      });\n    }\n  }\n  \n  /**\n   * Выполнение всех накопленных обновлений\n   */\n  private static flushUpdates(): void {\n    const updates = [...this.batchedUpdates];\n    this.batchedUpdates.length = 0;\n    this.isScheduled = false;\n    \n    updates.forEach(update => {\n      try {\n        update();\n      } catch (error) {\n        console.error('Ошибка в батчированном обновлении:', error);\n      }\n    });\n  }\n  \n  /**\n   * Виртуализация списков для больших наборов данных\n   */\n  static createVirtualList(items: any[], itemHeight: number, containerHeight: number) {\n    const visibleCount = Math.ceil(containerHeight / itemHeight) + 2; // +2 для буфера\n    let scrollTop = 0;\n    \n    return {\n      getVisibleItems() {\n        const startIndex = Math.floor(scrollTop / itemHeight);\n        const endIndex = Math.min(startIndex + visibleCount, items.length);\n        \n        return {\n          items: items.slice(startIndex, endIndex),\n          startIndex,\n          endIndex,\n          totalHeight: items.length * itemHeight,\n          offsetY: startIndex * itemHeight\n        };\n      },\n      \n      updateScrollTop(newScrollTop: number) {\n        scrollTop = newScrollTop;\n      }\n    };\n  }\n}\n\n/**\n * Менеджер памяти для предотвращения утечек\n */\nexport class MemoryManager {\n  private static cleanupFunctions: (() => void)[] = [];\n  \n  /**\n   * Регистрация функции очистки\n   */\n  static registerCleanup(cleanupFn: () => void): void {\n    this.cleanupFunctions.push(cleanupFn);\n  }\n  \n  /**\n   * Выполнение всех функций очистки\n   */\n  static cleanup(): void {\n    this.cleanupFunctions.forEach(fn => {\n      try {\n        fn();\n      } catch (error) {\n        console.error('Ошибка при очистке памяти:', error);\n      }\n    });\n    this.cleanupFunctions.length = 0;\n  }\n  \n  /**\n   * Мониторинг использования памяти\n   */\n  static getMemoryUsage(): any {\n    if ('memory' in performance) {\n      return (performance as any).memory;\n    }\n    return null;\n  }\n  \n  /**\n   * Принудительная сборка мусора (если доступна)\n   */\n  static forceGC(): void {\n    if ('gc' in window) {\n      (window as any).gc();\n    }\n  }\n}\n\n/**\n * Анализатор производительности\n */\nexport class PerformanceAnalyzer {\n  private static metrics = new Map<string, number[]>();\n  \n  /**\n   * Измерение времени выполнения\n   */\n  static measure<T>(name: string, fn: () => T): T {\n    const start = performance.now();\n    const result = fn();\n    const end = performance.now();\n    \n    this.recordTime(name, end - start);\n    \n    return result;\n  }\n  \n  /**\n   * Запись времени выполнения\n   */\n  static recordTime(name: string, time: number): void {\n    if (!this.metrics.has(name)) {\n      this.metrics.set(name, []);\n    }\n    \n    const times = this.metrics.get(name)!;\n    times.push(time);\n    \n    // Ограничиваем размер массива\n    if (times.length > 1000) {\n      times.shift();\n    }\n  }\n  \n  /**\n   * Получение отчета о производительности\n   */\n  static getReport(): Record<string, any> {\n    const report: any = {};\n    \n    for (const [name, times] of this.metrics) {\n      const sorted = [...times].sort((a, b) => a - b);\n      \n      report[name] = {\n        count: times.length,\n        min: sorted[0],\n        max: sorted[sorted.length - 1],\n        avg: times.reduce((sum, time) => sum + time, 0) / times.length,\n        median: sorted[Math.floor(sorted.length / 2)],\n        p95: sorted[Math.floor(sorted.length * 0.95)],\n        p99: sorted[Math.floor(sorted.length * 0.99)]\n      };\n    }\n    \n    return report;\n  }\n  \n  /**\n   * Очистка метрик\n   */\n  static clearMetrics(): void {\n    this.metrics.clear();\n  }\n}\n\n/**\n * Экспорт всех оптимизаций\n */\nexport default {\n  memoize,\n  debounce,\n  throttle,\n  ComponentOptimizer,\n  DOMOptimizer,\n  MemoryManager,\n  PerformanceAnalyzer\n};","import { ElementConfig, ElementChild, DOMPatch, DiffResult, PatchType } from './types';\n\n/**\n * Алгоритм сравнения конфигураций и создания патчей для DOM\n */\nexport class DOMDiffer {\n  /**\n   * Сравнение двух конфигураций элементов\n   */\n  diff(oldConfig: ElementConfig, newConfig: ElementConfig): DiffResult {\n    const patches: DOMPatch[] = [];\n    \n    // Если типы элементов разные - полная замена\n    if (this.isDifferentType(oldConfig, newConfig)) {\n      patches.push({\n        type: 'REPLACE',\n        oldConfig,\n        newConfig\n      });\n      return { patches };\n    }\n    \n    // Сравнение свойств\n    const propPatches = this.diffProps(oldConfig.props, newConfig.props);\n    if (propPatches.length > 0) {\n      patches.push({\n        type: 'PROPS',\n        props: this.mergeProps(propPatches)\n      });\n    }\n    \n    // Сравнение дочерних элементов\n    const childPatches = this.diffChildren(\n      oldConfig.children || [], \n      newConfig.children || []\n    );\n    patches.push(...childPatches);\n    \n    return { patches };\n  }\n  \n  /**\n   * Проверка, являются ли элементы разными типами\n   */\n  private isDifferentType(oldConfig: ElementConfig, newConfig: ElementConfig): boolean {\n    // Сравниваем теги\n    if (oldConfig.tag !== newConfig.tag) {\n      return true;\n    }\n    \n    // Сравниваем компоненты\n    if (oldConfig.component !== newConfig.component) {\n      return true;\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Сравнение свойств элементов\n   */\n  private diffProps(oldProps: any = {}, newProps: any = {}): Array<{key: string, type: 'add' | 'update' | 'remove', value?: any}> {\n    const patches: Array<{key: string, type: 'add' | 'update' | 'remove', value?: any}> = [];\n    const allKeys = new Set([...Object.keys(oldProps), ...Object.keys(newProps)]);\n    \n    for (const key of allKeys) {\n      const oldValue = oldProps[key];\n      const newValue = newProps[key];\n      \n      if (!(key in oldProps)) {\n        // Новое свойство\n        patches.push({ key, type: 'add', value: newValue });\n      } else if (!(key in newProps)) {\n        // Удаленное свойство\n        patches.push({ key, type: 'remove' });\n      } else if (!this.isEqual(oldValue, newValue)) {\n        // Измененное свойство\n        patches.push({ key, type: 'update', value: newValue });\n      }\n    }\n    \n    return patches;\n  }\n  \n  /**\n   * Сравнение дочерних элементов с поддержкой ключей\n   */\n  private diffChildren(oldChildren: ElementChild[], newChildren: ElementChild[]): DOMPatch[] {\n    const patches: DOMPatch[] = [];\n    \n    // Если есть ключи, используем оптимизированный алгоритм\n    if (this.hasKeys(oldChildren) || this.hasKeys(newChildren)) {\n      return this.diffChildrenWithKeys(oldChildren, newChildren);\n    }\n    \n    // Простое сравнение по позициям\n    const maxLength = Math.max(oldChildren.length, newChildren.length);\n    \n    for (let i = 0; i < maxLength; i++) {\n      const oldChild = oldChildren[i];\n      const newChild = newChildren[i];\n      \n      if (!oldChild && newChild) {\n        // Добавление нового элемента\n        patches.push({\n          type: 'ADD',\n          index: i,\n          newConfig: typeof newChild === 'string' ? undefined : newChild,\n          text: typeof newChild === 'string' ? newChild : undefined\n        });\n      } else if (oldChild && !newChild) {\n        // Удаление элемента\n        patches.push({\n          type: 'REMOVE',\n          index: i\n        });\n      } else if (oldChild && newChild) {\n        // Сравнение существующих элементов\n        if (typeof oldChild === 'string' && typeof newChild === 'string') {\n          if (oldChild !== newChild) {\n            patches.push({\n              type: 'TEXT_UPDATE',\n              index: i,\n              text: newChild\n            });\n          }\n        } else if (typeof oldChild === 'object' && typeof newChild === 'object') {\n          const childDiff = this.diff(oldChild, newChild);\n          if (childDiff.patches.length > 0) {\n            patches.push({\n              type: 'UPDATE',\n              index: i,\n              patches: childDiff.patches\n            });\n          }\n        } else {\n          // Разные типы - замена\n          patches.push({\n            type: 'REPLACE',\n            index: i,\n            oldConfig: typeof oldChild === 'object' ? oldChild : undefined,\n            newConfig: typeof newChild === 'object' ? newChild : undefined,\n            text: typeof newChild === 'string' ? newChild : undefined\n          });\n        }\n      }\n    }\n    \n    return patches;\n  }\n  \n  /**\n   * Оптимизированное сравнение дочерних элементов с ключами\n   */\n  private diffChildrenWithKeys(oldChildren: ElementChild[], newChildren: ElementChild[]): DOMPatch[] {\n    const patches: DOMPatch[] = [];\n    \n    // Создаем карты ключей для быстрого поиска\n    const oldKeyMap = this.createKeyMap(oldChildren);\n    const newKeyMap = this.createKeyMap(newChildren);\n    \n    // Отслеживаем обработанные элементы\n    const processedOldIndices = new Set<number>();\n    const processedNewIndices = new Set<number>();\n    \n    // Проходим по новым элементам\n    newChildren.forEach((newChild, newIndex) => {\n      const newKey = this.getKey(newChild, newIndex);\n      const oldIndex = oldKeyMap.get(newKey);\n      \n      if (oldIndex !== undefined) {\n        // Элемент существовал\n        const oldChild = oldChildren[oldIndex];\n        processedOldIndices.add(oldIndex);\n        processedNewIndices.add(newIndex);\n        \n        // Проверяем, нужно ли переместить\n        if (oldIndex !== newIndex) {\n          patches.push({\n            type: 'MOVE',\n            index: oldIndex,\n            newIndex: newIndex\n          });\n        }\n        \n        // Сравниваем содержимое\n        if (typeof oldChild === 'object' && typeof newChild === 'object') {\n          const childDiff = this.diff(oldChild, newChild);\n          if (childDiff.patches.length > 0) {\n            patches.push({\n              type: 'UPDATE',\n              index: newIndex,\n              patches: childDiff.patches\n            });\n          }\n        }\n      } else {\n        // Новый элемент\n        patches.push({\n          type: 'ADD',\n          index: newIndex,\n          newConfig: typeof newChild === 'object' ? newChild : undefined,\n          text: typeof newChild === 'string' ? newChild : undefined\n        });\n      }\n    });\n    \n    // Удаляем элементы, которых нет в новом списке\n    oldChildren.forEach((oldChild, oldIndex) => {\n      if (!processedOldIndices.has(oldIndex)) {\n        patches.push({\n          type: 'REMOVE',\n          index: oldIndex\n        });\n      }\n    });\n    \n    return patches;\n  }\n  \n  /**\n   * Создание карты ключей для быстрого поиска\n   */\n  private createKeyMap(children: ElementChild[]): Map<string | number, number> {\n    const keyMap = new Map<string | number, number>();\n    \n    children.forEach((child, index) => {\n      const key = this.getKey(child, index);\n      keyMap.set(key, index);\n    });\n    \n    return keyMap;\n  }\n  \n  /**\n   * Получение ключа элемента\n   */\n  private getKey(child: ElementChild, fallbackIndex: number): string | number {\n    if (typeof child === 'object' && child.key !== undefined) {\n      return child.key;\n    }\n    return fallbackIndex;\n  }\n  \n  /**\n   * Проверка наличия ключей в списке дочерних элементов\n   */\n  private hasKeys(children: ElementChild[]): boolean {\n    return children.some(child => \n      typeof child === 'object' && child.key !== undefined\n    );\n  }\n  \n  /**\n   * Объединение патчей для свойств\n   */\n  private mergeProps(propPatches: Array<{key: string, type: 'add' | 'update' | 'remove', value?: any}>): Record<string, any> {\n    const result: Record<string, any> = {};\n    \n    propPatches.forEach(patch => {\n      if (patch.type === 'remove') {\n        result[patch.key] = null; // Помечаем для удаления\n      } else {\n        result[patch.key] = patch.value;\n      }\n    });\n    \n    return result;\n  }\n  \n  /**\n   * Глубокое сравнение значений\n   */\n  private isEqual(value1: any, value2: any): boolean {\n    if (value1 === value2) {\n      return true;\n    }\n    \n    if (value1 == null || value2 == null) {\n      return value1 === value2;\n    }\n    \n    if (typeof value1 !== typeof value2) {\n      return false;\n    }\n    \n    if (typeof value1 === 'object') {\n      // Простое сравнение объектов (можно улучшить)\n      return JSON.stringify(value1) === JSON.stringify(value2);\n    }\n    \n    return false;\n  }\n}\n\n/**\n * Применение патчей к DOM элементу\n */\nexport class DOMPatcher {\n  /**\n   * Применение списка патчей к DOM элементу\n   */\n  patch(element: HTMLElement, patches: DOMPatch[]): HTMLElement {\n    let currentElement = element;\n    \n    patches.forEach(patch => {\n      currentElement = this.applyPatch(currentElement, patch);\n    });\n    \n    return currentElement;\n  }\n  \n  /**\n   * Применение одного патча\n   */\n  private applyPatch(element: HTMLElement, patch: DOMPatch): HTMLElement {\n    switch (patch.type) {\n      case 'REPLACE':\n        return this.replacePatch(element, patch);\n      case 'PROPS':\n        this.propsPatch(element, patch);\n        break;\n      case 'ADD':\n        this.addPatch(element, patch);\n        break;\n      case 'REMOVE':\n        this.removePatch(element, patch);\n        break;\n      case 'UPDATE':\n        this.updatePatch(element, patch);\n        break;\n      case 'TEXT_UPDATE':\n        this.textUpdatePatch(element, patch);\n        break;\n      case 'MOVE':\n        this.movePatch(element, patch);\n        break;\n    }\n    \n    return element;\n  }\n  \n  /**\n   * Полная замена элемента\n   */\n  private replacePatch(element: HTMLElement, patch: DOMPatch): HTMLElement {\n    if (!patch.newConfig) {\n      throw new Error('Новая конфигурация требуется для замены');\n    }\n    \n    // Здесь нужно создать новый элемент из конфигурации\n    // Это требует доступа к renderer'у\n    // Пока оставляем заглушку\n    console.warn('Замена элемента еще не реализована');\n    return element;\n  }\n  \n  /**\n   * Обновление свойств элемента\n   */\n  private propsPatch(element: HTMLElement, patch: DOMPatch): void {\n    if (!patch.props) return;\n    \n    Object.entries(patch.props).forEach(([key, value]) => {\n      if (value === null) {\n        // Удаление свойства\n        element.removeAttribute(key);\n      } else {\n        // Установка/обновление свойства\n        if (key === 'style' && typeof value === 'object') {\n          this.updateStyles(element, value);\n        } else if (key === 'class') {\n          element.className = value;\n        } else {\n          element.setAttribute(key, String(value));\n        }\n      }\n    });\n  }\n  \n  /**\n   * Добавление нового дочернего элемента\n   */\n  private addPatch(element: HTMLElement, patch: DOMPatch): void {\n    const index = patch.index || element.children.length;\n    \n    if (patch.text !== undefined) {\n      // Текстовый узел\n      const textNode = document.createTextNode(patch.text);\n      if (index >= element.children.length) {\n        element.appendChild(textNode);\n      } else {\n        element.insertBefore(textNode, element.children[index]);\n      }\n    } else if (patch.newConfig) {\n      // Новый элемент из конфигурации\n      // Требует доступа к renderer'у\n      console.warn('Добавление элемента из конфигурации еще не реализовано');\n    }\n  }\n  \n  /**\n   * Удаление дочернего элемента\n   */\n  private removePatch(element: HTMLElement, patch: DOMPatch): void {\n    const index = patch.index;\n    if (index !== undefined && index < element.children.length) {\n      const child = element.children[index];\n      element.removeChild(child);\n    }\n  }\n  \n  /**\n   * Обновление дочернего элемента\n   */\n  private updatePatch(element: HTMLElement, patch: DOMPatch): void {\n    const index = patch.index;\n    if (index !== undefined && index < element.children.length && patch.patches) {\n      const child = element.children[index] as HTMLElement;\n      this.patch(child, patch.patches);\n    }\n  }\n  \n  /**\n   * Обновление текста\n   */\n  private textUpdatePatch(element: HTMLElement, patch: DOMPatch): void {\n    const index = patch.index;\n    if (index !== undefined && patch.text !== undefined) {\n      const child = element.childNodes[index];\n      if (child && child.nodeType === Node.TEXT_NODE) {\n        child.textContent = patch.text;\n      }\n    }\n  }\n  \n  /**\n   * Перемещение элемента\n   */\n  private movePatch(element: HTMLElement, patch: DOMPatch): void {\n    const oldIndex = patch.index;\n    const newIndex = patch.newIndex;\n    \n    if (oldIndex !== undefined && newIndex !== undefined) {\n      const child = element.children[oldIndex];\n      const target = element.children[newIndex];\n      \n      if (child) {\n        if (target) {\n          element.insertBefore(child, target);\n        } else {\n          element.appendChild(child);\n        }\n      }\n    }\n  }\n  \n  /**\n   * Обновление стилей элемента\n   */\n  private updateStyles(element: HTMLElement, styles: Record<string, any>): void {\n    Object.entries(styles).forEach(([property, value]) => {\n      if (value === null || value === undefined) {\n        element.style.removeProperty(property);\n      } else {\n        element.style.setProperty(property, String(value));\n      }\n    });\n  }\n}\n\n/**\n * Глобальные экземпляры для удобства\n */\nexport const domDiffer = new DOMDiffer();\nexport const domPatcher = new DOMPatcher();","import { ElementConfig } from '../core/types';\n\n/**\n * Утилиты для работы с элементами\n */\n\n/**\n * Создание простого элемента с минимальной конфигурацией\n */\nexport function createElement(tag: string, props?: any, children?: any[]): ElementConfig {\n  const config: ElementConfig = {\n    tag,\n    props\n  };\n  \n  if (children !== undefined) {\n    config.children = children;\n  }\n  \n  return config;\n}\n\n/**\n * Проверка валидности HTML тега\n */\nexport function isValidHtmlTag(tag: string): boolean {\n  const validTags = [\n    'div', 'span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\n    'button', 'input', 'form', 'label', 'textarea', 'select', 'option',\n    'a', 'img', 'ul', 'ol', 'li', 'table', 'tr', 'td', 'th',\n    'header', 'footer', 'main', 'section', 'article', 'nav',\n    'strong', 'em', 'small', 'br', 'hr'\n  ];\n  return validTags.includes(tag.toLowerCase());\n}\n\n/**\n * Преобразование camelCase в kebab-case\n */\nexport function camelToKebab(str: string): string {\n  return str.replace(/([A-Z])/g, '-$1').toLowerCase();\n}\n\n/**\n * Escape HTML специальных символов\n */\nexport function escapeHtml(text: string): string {\n  const div = document.createElement('div');\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n/**\n * Проверка является ли объект ElementConfig\n */\nexport function isElementConfig(obj: any): obj is ElementConfig {\n  return obj && typeof obj === 'object' && typeof obj.tag === 'string';\n}\n\n/**\n * Глубокое клонирование конфигурации\n */\nexport function cloneConfig(config: ElementConfig): ElementConfig {\n  return JSON.parse(JSON.stringify(config));\n}\n\n/**\n * Создание текстового узла\n */\nexport function createTextNode(text: string): string {\n  return String(text);\n}\n\n/**\n * Объединение CSS классов\n */\nexport function combineClasses(...classes: (string | undefined | null)[]): string {\n  return classes.filter(Boolean).join(' ');\n}\n\n/**\n * Преобразование объекта стилей в CSS строку\n */\nexport function stylesToString(styles: Record<string, string | number>): string {\n  return Object.entries(styles)\n    .map(([key, value]) => `${camelToKebab(key)}: ${value}`)\n    .join('; ');\n}","// Основные классы\nexport { ConfigValidator } from './core/validator';\nexport { HTMLRenderer } from './core/renderer';\nexport { ComponentRenderer } from './core/component-renderer';\nexport { componentRegistry, registerComponent, getComponent, createComponentInstance } from './core/component-registry';\n\n// Реактивность\nexport { \n  createReactive, \n  effect, \n  stop, \n  isReactive, \n  toRaw, \n  shallowReactive,\n  pauseTracking,\n  enableTracking\n} from './core/reactive';\n\n// Computed свойства\nexport {\n  computed,\n  isComputedRef,\n  useComputed,\n  memo,\n  createComponentComputed,\n  computedManager\n} from './core/computed';\n\n// Система плагинов\nexport {\n  PluginManager,\n  definePlugin,\n  LifecycleLoggerPlugin,\n  FormValidationPlugin,\n  I18nPlugin,\n  StorePlugin\n} from './core/plugin-system';\n\n// Планировщик\nexport { \n  scheduler, \n  nextTick, \n  flushSync, \n  scheduleUpdate,\n  PriorityScheduler \n} from './core/scheduler';\n\n// Директивы\nexport { \n  directiveManager,\n  IfDirective,\n  ForDirective, \n  ShowDirective,\n  ModelDirective\n} from './core/directives';\n\n// Оптимизация производительности\nexport {\n  memoize,\n  debounce,\n  throttle,\n  ComponentOptimizer,\n  DOMOptimizer,\n  MemoryManager,\n  PerformanceAnalyzer\n} from './core/performance';\n\n// DOM Diffing\nexport { domDiffer, domPatcher, DOMDiffer, DOMPatcher } from './core/dom-differ';\n\n// Типы\nexport type { \n  ElementConfig, \n  ElementProps, \n  StyleProperties, \n  ElementChild, \n  EventHandlers,\n  ValidationResult,\n  ValidationError,\n  RenderContext,\n  EventListenerRecord,\n  RendererOptions,\n  RenderStats,\n  \n  // Компонентная система\n  Component,\n  ComponentProps,\n  PropDefinition,\n  ComponentInstance,\n  \n  // Реактивность\n  ReactiveEffect,\n  EffectOptions,\n  ReactiveProperty,\n  ReactiveOptions,\n  DebuggerEvent,\n  \n  // DOM Diffing\n  PatchType,\n  DOMPatch,\n  DiffResult,\n  \n  // Директивы\n  DirectiveContext,\n  \n  // Computed свойства\n  ComputedRef,\n  ComputedOptions,\n  \n  // Система плагинов\n  Plugin,\n  PluginOptions,\n  PluginContext,\n  CustomDirective,\n  DirectiveBinding\n} from './core/types';\n\n// Утилиты\nexport { \n  createElement, \n  isValidHtmlTag, \n  camelToKebab,\n  escapeHtml,\n  isElementConfig,\n  cloneConfig,\n  createTextNode,\n  combineClasses,\n  stylesToString\n} from './utils/helpers';\n\nimport { ConfigValidator } from './core/validator';\nimport { ComponentRenderer } from './core/component-renderer';\nimport { ElementConfig, RendererOptions, Component, Plugin, PluginOptions, CustomDirective } from './core/types';\nimport { createReactive } from './core/reactive';\nimport { registerComponent } from './core/component-registry';\nimport { nextTick } from './core/scheduler';\nimport { computed } from './core/computed';\nimport { PluginManager } from './core/plugin-system';\n\n/**\n * Основной класс JS фреймворка с поддержкой компонентов, реактивности, плагинов и computed свойств\n */\nexport class JSFramework {\n  private renderer: ComponentRenderer;\n  private validator: ConfigValidator;\n  private mountedElement: HTMLElement | null;\n  private globalState: any;\n  private pluginManager: PluginManager;\n\n  constructor(options?: RendererOptions) {\n    this.renderer = new ComponentRenderer();\n    this.validator = new ConfigValidator();\n    this.mountedElement = null;\n    this.globalState = createReactive({});\n    this.pluginManager = new PluginManager(this);\n  }\n\n  /**\n   * Регистрация компонента в фреймворке\n   */\n  registerComponent(component: Component): void {\n    registerComponent(component);\n  }\n\n  /**\n   * Создание реактивного состояния\n   */\n  reactive<T extends object>(target: T): T {\n    return createReactive(target);\n  }\n\n  /**\n   * Получение глобального состояния\n   */\n  getGlobalState(): any {\n    return this.globalState;\n  }\n\n  /**\n   * Ожидание следующего обновления\n   */\n  nextTick(): Promise<void> {\n    return nextTick();\n  }\n\n  /**\n   * Создание computed свойства\n   */\n  computed<T>(getter: () => T): any {\n    return computed(getter);\n  }\n\n  /**\n   * Установка плагина\n   */\n  use(plugin: Plugin, options?: PluginOptions): this {\n    this.pluginManager.use(plugin, options);\n    return this;\n  }\n\n  /**\n   * Регистрация пользовательской директивы\n   */\n  directive(directive: CustomDirective): this {\n    this.pluginManager.registerDirective(directive);\n    return this;\n  }\n\n  /**\n   * Добавление глобального свойства\n   */\n  config(name: string, value: any): this {\n    this.pluginManager.addGlobalProperty(name, value);\n    return this;\n  }\n\n  /**\n   * Получение установленных плагинов\n   */\n  getInstalledPlugins(): string[] {\n    return this.pluginManager.getInstalledPlugins();\n  }\n\n  /**\n   * Рендеринг конфигурации в указанный контейнер\n   */\n  render(config: ElementConfig, container: HTMLElement | string): HTMLElement {\n    const containerElement = typeof container === 'string' \n      ? document.querySelector(container) as HTMLElement\n      : container;\n\n    if (!containerElement) {\n      throw new Error('Контейнер не найден');\n    }\n\n    // Валидация конфигурации\n    const validationResult = this.validator.validate(config);\n    if (!validationResult.isValid) {\n      const errorMessages = validationResult.errors.map(e => e.message).join(', ');\n      throw new Error(`Ошибка валидации: ${errorMessages}`);\n    }\n\n    // Размонтируем предыдущий элемент\n    if (this.mountedElement) {\n      this.unmount();\n    }\n\n    // Рендеринг с поддержкой компонентов\n    const element = this.renderer.render(config, containerElement);\n    this.mountedElement = element;\n\n    return element;\n  }\n\n  /**\n   * Размонтирование текущего элемента\n   */\n  unmount(): void {\n    if (this.mountedElement) {\n      this.renderer.unmount(this.mountedElement);\n      this.mountedElement = null;\n    }\n  }\n\n  /**\n   * Обновление текущего элемента новой конфигурацией\n   */\n  update(newConfig: ElementConfig): HTMLElement {\n    if (!this.mountedElement) {\n      throw new Error('Нет смонтированного элемента для обновления');\n    }\n\n    // Валидация новой конфигурации\n    const validationResult = this.validator.validate(newConfig);\n    if (!validationResult.isValid) {\n      const errorMessages = validationResult.errors.map(e => e.message).join(', ');\n      throw new Error(`Ошибка валидации: ${errorMessages}`);\n    }\n\n    // Обновление с поддержкой компонентов\n    const newElement = this.renderer.updateElement(this.mountedElement, newConfig);\n    this.mountedElement = newElement;\n\n    return newElement;\n  }\n\n  /**\n   * Получение статистики рендеринга\n   */\n  getStats() {\n    return this.renderer.getStats();\n  }\n\n  /**\n   * Поиск элемента по ID\n   */\n  findById(id: string): HTMLElement | null {\n    if (!this.mountedElement) {\n      return null;\n    }\n    return this.renderer.findElementById(this.mountedElement, id);\n  }\n\n  /**\n   * Поиск элементов по классу\n   */\n  findByClass(className: string): HTMLElement[] {\n    if (!this.mountedElement) {\n      return [];\n    }\n    return this.renderer.findElementsByClass(this.mountedElement, className);\n  }\n\n  /**\n   * Очистка всех ресурсов фреймворка включая плагины\n   */\n  cleanup(): void {\n    this.unmount();\n    this.renderer.cleanup();\n    this.validator.reset();\n    this.pluginManager.cleanup();\n  }\n\n  /**\n   * Получение текущего смонтированного элемента\n   */\n  getMountedElement(): HTMLElement | null {\n    return this.mountedElement;\n  }\n}\n\n// Создание глобального экземпляра для удобства\nexport const Framework = new JSFramework();\n\n// Экспорт по умолчанию\nexport default Framework;","import { \n  ElementConfig, \n  ElementProps, \n  StyleProperties, \n  EventHandlers, \n  EventListenerRecord, \n  RenderContext,\n  RendererOptions,\n  RenderStats\n} from './types';\n\n/**\n * Класс для рендеринга HTML элементов из конфигурации\n */\nexport class HTMLRenderer {\n  private eventListeners: Map<HTMLElement, EventListenerRecord[]>;\n  private options: RendererOptions;\n  private stats: RenderStats;\n\n  constructor(options: RendererOptions = {}) {\n    this.eventListeners = new Map();\n    this.options = {\n      enableValidation: true,\n      enableLogging: false,\n      ...options\n    };\n    this.stats = {\n      elementsCreated: 0,\n      eventsAttached: 0,\n      renderTime: 0\n    };\n  }\n\n  /**\n   * Основной метод рендеринга\n   */\n  render(config: ElementConfig, container: HTMLElement): HTMLElement {\n    const startTime = performance.now();\n    \n    try {\n      const element = this.createElement(config);\n      container.appendChild(element);\n      \n      this.stats.renderTime = performance.now() - startTime;\n      \n      if (this.options.enableLogging) {\n        console.log(`Рендеринг завершен за ${this.stats.renderTime.toFixed(2)}мс`);\n      }\n      \n      return element;\n    } catch (error) {\n      console.error('Ошибка рендеринга:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Создание DOM элемента из конфигурации\n   */\n  private createElement(config: ElementConfig): HTMLElement {\n    // Создание HTML элемента\n    const tag = config.tag || 'div';\n    const element = document.createElement(tag);\n    this.stats.elementsCreated++;\n\n    // Применение свойств\n    if (config.props) {\n      this.applyProps(element, config.props);\n    }\n\n    // Привязка событий\n    if (config.events) {\n      this.attachEvents(element, config.events);\n    }\n\n    // Рендеринг дочерних элементов\n    if (config.children) {\n      this.renderChildren(element, config.children);\n    }\n\n    return element;\n  }\n\n  /**\n   * Применение свойств к DOM элементу\n   */\n  private applyProps(element: HTMLElement, props: ElementProps): void {\n    for (const [key, value] of Object.entries(props)) {\n      switch (key) {\n        case 'class':\n          element.className = value as string;\n          break;\n        case 'id':\n          element.id = value as string;\n          break;\n        case 'style':\n          this.applyStyles(element, value as StyleProperties);\n          break;\n        default:\n          // Применение обычных HTML атрибутов\n          if (value !== undefined && value !== null) {\n            element.setAttribute(key, String(value));\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * Применение CSS стилей к элементу\n   */\n  private applyStyles(element: HTMLElement, styles: StyleProperties): void {\n    for (const [property, value] of Object.entries(styles)) {\n      if (value !== undefined && value !== null) {\n        // Преобразование camelCase в kebab-case для CSS свойств\n        const cssProperty = property.replace(/([A-Z])/g, '-$1').toLowerCase();\n        element.style.setProperty(cssProperty, String(value));\n      }\n    }\n  }\n\n  /**\n   * Привязка обработчиков событий к элементу\n   */\n  private attachEvents(element: HTMLElement, events: EventHandlers): void {\n    const listeners: EventListenerRecord[] = [];\n\n    for (const [eventType, handler] of Object.entries(events)) {\n      if (!handler) continue; // Пропускаем undefined обработчики\n      \n      // Обрабатываем кастомные события фреймворка\n      if (eventType === 'mounted' || eventType === 'unmounted') {\n        // Кастомные события не добавляются как DOM listeners\n        continue;\n      }\n      \n      const listenerRecord: EventListenerRecord = {\n        type: eventType,\n        handler: handler as (event: Event) => void,\n        element\n      };\n\n      element.addEventListener(eventType, handler as EventListener);\n      listeners.push(listenerRecord);\n      this.stats.eventsAttached++;\n    }\n\n    if (listeners.length > 0) {\n      this.eventListeners.set(element, listeners);\n    }\n  }\n\n  /**\n   * Рендеринг дочерних элементов\n   */\n  private renderChildren(parent: HTMLElement, children: any[]): void {\n    children.forEach(child => {\n      if (typeof child === 'string') {\n        // Текстовый узел\n        const textNode = document.createTextNode(child);\n        parent.appendChild(textNode);\n      } else if (child && typeof child === 'object' && child.tag) {\n        // Вложенный элемент\n        const childElement = this.createElement(child);\n        parent.appendChild(childElement);\n      } else {\n        console.warn('Некорректный дочерний элемент:', child);\n      }\n    });\n  }\n\n  /**\n   * Размонтирование элемента с очисткой ресурсов\n   */\n  unmount(element: HTMLElement): void {\n    // Очистка обработчиков событий\n    this.cleanupEventListeners(element);\n\n    // Рекурсивная очистка дочерних элементов\n    const children = Array.from(element.children);\n    children.forEach(child => {\n      if (child instanceof HTMLElement) {\n        this.unmount(child);\n      }\n    });\n\n    // Удаление из DOM\n    if (element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n  }\n\n  /**\n   * Очистка обработчиков событий для элемента\n   */\n  private cleanupEventListeners(element: HTMLElement): void {\n    const listeners = this.eventListeners.get(element);\n    if (listeners) {\n      listeners.forEach(({ type, handler }) => {\n        element.removeEventListener(type, handler);\n      });\n      this.eventListeners.delete(element);\n    }\n  }\n\n  /**\n   * Обновление элемента новой конфигурацией\n   */\n  update(element: HTMLElement, newConfig: ElementConfig): HTMLElement {\n    // Простое обновление - полная замена\n    const parent = element.parentNode;\n    if (!parent) {\n      throw new Error('Элемент не имеет родителя для обновления');\n    }\n\n    // Создание нового элемента\n    const newElement = this.createElement(newConfig);\n\n    // Замена в DOM\n    parent.replaceChild(newElement, element);\n\n    // Очистка старого элемента\n    this.unmount(element);\n\n    return newElement;\n  }\n\n  /**\n   * Получение статистики рендеринга\n   */\n  getStats(): RenderStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Сброс статистики рендеринга\n   */\n  resetStats(): void {\n    this.stats = {\n      elementsCreated: 0,\n      eventsAttached: 0,\n      renderTime: 0\n    };\n  }\n\n  /**\n   * Получение количества привязанных обработчиков событий\n   */\n  getEventListenersCount(): number {\n    let count = 0;\n    this.eventListeners.forEach(listeners => {\n      count += listeners.length;\n    });\n    return count;\n  }\n\n  /**\n   * Создание контекста рендеринга\n   */\n  createRenderContext(element: HTMLElement, config: ElementConfig, parent?: RenderContext): RenderContext {\n    return {\n      element,\n      config,\n      ...(parent && { parentContext: parent })\n    };\n  }\n\n  /**\n   * Поиск элемента по ID в рендереном дереве\n   */\n  findElementById(root: HTMLElement, id: string): HTMLElement | null {\n    if (root.id === id) {\n      return root;\n    }\n\n    for (const child of Array.from(root.children)) {\n      if (child instanceof HTMLElement) {\n        const found = this.findElementById(child, id);\n        if (found) {\n          return found;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Поиск элементов по классу в рендереном дереве\n   */\n  findElementsByClass(root: HTMLElement, className: string): HTMLElement[] {\n    const result: HTMLElement[] = [];\n\n    if (root.classList.contains(className)) {\n      result.push(root);\n    }\n\n    for (const child of Array.from(root.children)) {\n      if (child instanceof HTMLElement) {\n        result.push(...this.findElementsByClass(child, className));\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Очистка всех ресурсов рендерера\n   */\n  cleanup(): void {\n    // Очистка всех обработчиков событий\n    this.eventListeners.forEach((listeners, element) => {\n      listeners.forEach(({ type, handler }) => {\n        element.removeEventListener(type, handler);\n      });\n    });\n\n    this.eventListeners.clear();\n    this.resetStats();\n  }\n}"],"names":["ConfigValidator","constructor","this","validHtmlTags","Set","usedIds","reset","clear","validate","config","path","errors","validateTag","props","validateProps","children","validateChildren","events","validateEvents","isValid","length","push","field","message","component","tag","has","toLowerCase","class","id","add","style","validateStyles","property","value","Object","entries","Array","isArray","forEach","child","index","childPath","childResult","eventType","handler","isValidEventType","includes","getSupportedTags","from","addSupportedTag","removeSupportedTag","delete","activeEffect","effectStack","targetMap","WeakMap","reactiveMap","originalMap","createReactive","target","options","get","proxy","Proxy","obj","prop","receiver","key","shouldTrack","depsMap","set","Map","dep","String","effects","deps","track","Reflect","deep","debuggerOptions","onTrack","type","newValue","oldValue","hadKey","prototype","hasOwnProperty","call","result","trigger","onTrigger","deleteProperty","effect","lengthDep","scheduler","fn","effectFn","active","lazy","cleanupEffect","pop","runEffect","stop","componentRegistry","components","instances","instanceCounter","register","name","Error","console","warn","validateComponent","unregister","activeInstances","values","filter","instance","mounted","createInstance","componentName","generateInstanceId","validatedProps","validateAndNormalizeProps","beforeCreate","error","reactiveState","state","computedProperties","computed","getter","defineProperty","enumerable","configurable","element","dependencies","parent","pluginContext","cleanup","created","getInstance","destroyInstance","unmountInstance","destroyed","mountInstance","beforeMount","beforeDestroy","cleanupFn","updateInstanceProps","newProps","changedProps","beforeUpdate","updated","getInstancesByComponent","getMountedInstances","clearInstances","getRegisteredComponents","keys","getStats","mountedCount","registeredComponents","size","totalInstances","mountedInstances","unmountedInstances","render","propName","propDef","isValidPropDefinition","propDefinitions","required","validatePropType","validator","default","expectedType","isNaN","Date","now","registerComponent","updateQueue","isFlushPending","isFlushActive","currentFlushPromise","schedule","scheduleFlush","scheduleUpdate","Promise","resolve","requestAnimationFrame","flushUpdates","nextTick","flushSync","getQueueSize","isActive","callback","then","PriorityScheduler","highPriorityQueue","normalPriorityQueue","lowPriorityQueue","priority","flush","executeQueue","executeQueueWithTimeSlicing","queue","shift","startTime","performance","BaseDirective","IfDirective","super","arguments","process","context","if","evaluateExpression","_","cleanConfig","expression","func","Function","Boolean","ForDirective","for","template","items","itemName","indexName","parseForExpression","itemsArray","map","item","itemContext","processTemplate","withParentheses","match","simple","processedTemplate","JSON","parse","stringify","interpolateString","str","replace","trim","ShowDirective","show","shouldShow","processedConfig","display","_ModelDirective","model","handleInputModel","handleTextareaModel","handleSelectModel","originalMounted","modelBindings","propertyPath","currentValue","getPropertyValue","checked","change","event","setPropertyValue","input","pathParts","parsePath","i","part","lastPart","triggerUpdate","parts","segments","split","segment","arrayMatch","parseInt","scheduler$1","catch","updateBoundElements","binding","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","ModelDirective","directiveManager","directives","directive","processDirectives","results","directiveOrder","directiveName","newResults","configItem","processed","hasDirectives","ComponentRenderer","instanceElements","stats","elementsCreated","eventsAttached","renderTime","container","clearContainer","renderConfig","appendChild","parentInstance","renderComponent","renderElement","directiveContext","componentConfig","processedConfigs","unmountComponent","newElement","parentNode","replaceChild","createPlaceholder","document","createElement","applyProps","attachEvents","renderChildren","textNode","createTextNode","childElement","className","applyStyles","setAttribute","styles","cssProperty","setProperty","cssText","addEventListener","removeChild","placeholder","contains","innerHTML","updateElement","newConfig","unmount","getComponentInstance","forceUpdate","findElementById","querySelector","findElementsByClass","querySelectorAll","ComputedRefImpl","setter","_dirty","_setter","_effect","_value","dirty","invalidate","getterOrOptions","computedManager","computedRefs","computedRef","invalidateAll","clean","total","PluginManager","framework","plugins","installedPlugins","globalProperties","customDirectives","frameworkInstance","use","plugin","dependency","fromEntries","install","log","uninstall","pluginName","hasPlugin","getInstalledPlugins","addGlobalProperty","getGlobalProperty","registerDirective","getDirective","getAllDirectives","definePlugin","version","LifecycleLoggerPlugin","enabled","logLifecycle","hook","data","FormValidationPlugin","validateDirective","bind","el","classList","toggle","validators","email","test","minLength","min","maxLength","max","pattern","regex","I18nPlugin","messages","currentLocale","locale","t","params","reduce","msg","paramKey","RegExp","setLocale","getLocale","i18nDirective","textContent","update","StorePlugin","initialState","mutations","actions","reactive","store","commit","mutationName","payload","mutation","dispatch","actionName","action","$store","ComponentOptimizer","renderCache","performanceMetrics","cacheRender","componentId","generateCacheKey","timestamp","cleanupCache","getCachedRender","cached","measureRenderTime","renderFn","start","end","recordMetric","getMetrics","times","avg","a","b","Math","count","time","DOMOptimizer","batchUpdate","updateFn","batchedUpdates","isScheduled","updates","createVirtualList","itemHeight","containerHeight","visibleCount","ceil","scrollTop","getVisibleItems","startIndex","floor","endIndex","slice","totalHeight","offsetY","updateScrollTop","newScrollTop","MemoryManager","registerCleanup","cleanupFunctions","getMemoryUsage","memory","forceGC","window","gc","PerformanceAnalyzer","measure","recordTime","metrics","getReport","report","sorted","sort","sum","median","p95","p99","clearMetrics","DOMDiffer","diff","oldConfig","patches","isDifferentType","propPatches","diffProps","mergeProps","childPatches","diffChildren","oldProps","allKeys","isEqual","oldChildren","newChildren","hasKeys","diffChildrenWithKeys","oldChild","newChild","text","childDiff","oldKeyMap","createKeyMap","processedOldIndices","processedNewIndices","newIndex","newKey","getKey","oldIndex","keyMap","fallbackIndex","some","patch","value1","value2","DOMPatcher","currentElement","applyPatch","replacePatch","propsPatch","addPatch","removePatch","updatePatch","textUpdatePatch","movePatch","removeAttribute","updateStyles","insertBefore","childNodes","nodeType","Node","TEXT_NODE","removeProperty","domDiffer","domPatcher","camelToKebab","JSFramework","renderer","mountedElement","globalState","pluginManager","getGlobalState","containerElement","validationResult","errorMessages","e","join","findById","findByClass","getMountedElement","Framework","eventListeners","enableValidation","enableLogging","toFixed","listeners","listenerRecord","cleanupEventListeners","HTMLElement","removeEventListener","resetStats","getEventListenersCount","createRenderContext","parentContext","root","found","classes","onDestroy","destroy","wait","timeout","args","clearTimeout","setTimeout","div","r","cachedValue","cachedDeps","isInitialized","keyGenerator","cache","firstKey","next","limit","inThrottle","observed","original"],"mappings":"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"}